
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8" />
        <title>GoldenPanda&#39;s Blog</title>
        <meta name="author" content="金冠小熊猫" />
        <meta name="description" content="温故而知新" />
        <meta name="keywords" content="菜狗大学生" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>GOLDENPANDA&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;GOLDENPANDA&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/1.jpg,/images/2.jpg,/images/3.jpg,/images/4.jpg,/images/5.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>GoldenPanda&#39;s Blog</h1>
                <h3>欢迎来到米奇妙妙屋</h3>
                <h5>温故而知新</h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap"  ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2022/11/05/%E6%8F%92%E5%85%A5%E8%BF%98%E6%98%AF%E5%A0%86%E6%8E%92%E5%BA%8F/">
        <h2 class="post-title">插入还是堆排序</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/5
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1590/">https://www.acwing.com/problem/content/1590/</a><br> <p>根据维基百科：</p></p>
<p>插入排序迭代，每次将一个插入元素插入到排好序的输出序列中，每次迭代插入排序都会从输入数据中移除一个元素，并在已排好序的序列中找到它所属的位置，然后将其插入。直到没有输入元素剩余为止。</p>
<p>堆排序将其输入分为已排序和未排序两个区域，并通过提取未排序区域中的最大元素并将其移至已排序的区域来迭代地缩小未排序的区域。它通过使用堆数据结构而非线性时间搜索来找到最大值。</p>
<p>现在，给定初始序列，以及经过某种排序方法多次迭代后的序列，请你判断我们使用的哪一种排序方法。</p>
<h4>注意</h4>
<p>本题题目描述中曾提到保证答案唯一。</p>
<p>不应该出现诸如下列的样例情况：</p>
<pre><code>9
3 1 2 8 7 9 4 6 0
1 2 3 7 8 9 4 6 0
</code></pre>

<p>这种样例情况，无法确定插入排序进行到了第五项还是第六项。</p>
<p>在本网站提供的数据中，并不涉及这种情况。</p>
<p>但是 PAT 官网给出了类似样例，因而可能会出现一些代码在本网站能够 AC，但在 PAT 官网 WA 的情况，特此加以声明。</p>
<h4>输入格式</h4>
<p>第一行包含整数 $N$，表示序列中整数个数。</p>
<p>第二行包含 $N$ 个整数表示初始序列。</p>
<p>第三行包含 $N$ 个整数表示经过若干次迭代后的序列。</p>
<p>假定排序的目标序列总是递增的。</p>
<h4>输出格式</h4>
<p>第一行输出 <code>Insertion Sort</code> 或 <code>Heap Sort</code>，以指明所采用的具体排序方法。</p>
<p>运用此方法再进行一次迭代，并在第二行输出本次迭代后的序列。</p>
<p>数据保证答案唯一。</p>
<h4>数据范围</h4>
<p>$1 \le N \le 100$</p>
<h4>输入样例1：</h4>
<pre><code>10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
</code></pre>

<h4>输出样例1：</h4>
<pre><code>Insertion Sort
1 2 3 5 7 8 9 4 6 0
</code></pre>

<h4>输入样例2：</h4>
<pre><code>10
3 1 2 8 7 5 9 4 6 0
6 4 5 1 0 3 2 7 8 9
</code></pre>

<h4>输出样例2：</h4>
<pre><code>Heap Sort
5 4 3 1 0 2 6 7 8 9
</code></pre>

<p>复习一下堆排序，堆是一个递归定义的结构<strong>：父亲节点是整颗子树的最值</strong>。这样，对于根节点来说，根节点的左右儿子是左右子树的最值，而<strong>根节点又是{左儿子、右儿子、根节点}之中的最值</strong>，所以<strong>根节点是整颗树的最值</strong>。<br>存储的时候用一个<strong>一维数组</strong>就可以存储<strong>一个完全二叉树</strong>。<br>初始化堆的时候当然一个一个插入也是可以的这是nlogn的，但是有o(n)的建堆方式，即：从n &#x2F; 2的位置一步步down到1；<br>在用一维数组维护堆的时候，通常要维护一个<strong>int size;<strong>方便O(1)插入，快速删除。<br>在</strong>删除</strong>的时候用heap[size]的元素“覆盖掉”h[1]就好了，然后<strong>down()<strong>一遍</strong>(看似是删除，实际是“覆盖”，达到删除的效果，而且用末尾元素也是我们维护size的原因)</strong><br>在<strong>插入</strong>的时候直接插入到h[size];然后**up()**一遍</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 110;
int a[N],b[N],n;
void down(int u,int size)
&#123;
    int t = u;
    if(b[u * 2] &gt; b[t] &amp;&amp; u * 2 &lt;= size) t = u * 2;
    if(b[u * 2 + 1] &gt; b[t] &amp;&amp; u * 2 + 1 &lt;= size) t = u * 2 + 1;
    if(t != u)
    &#123;
        swap(b[t],b[u]);
        down(t,size);
    &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n;
    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];
    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; b[i];
    
    int pos = 1;
    while(pos + 1 &lt;= n &amp;&amp; b[pos] &lt;= b[pos + 1]) pos ++;
    pos ++;
    bool is_insert = true;
    for(int i = pos;i &lt;= n;i ++)
    &#123;
        if(a[i] != b[i]) &#123;is_insert = false;break;&#125;
    &#125;
    if(is_insert)
    &#123;
        puts(&quot;Insertion Sort&quot;);
        int i = pos;
        while(i &gt; 1 &amp;&amp; b[i] &lt;= b[i - 1]) &#123;swap(b[i],b[i - 1]);i --;&#125;
    &#125;
    else
    &#123;
        puts(&quot;Heap Sort&quot;);
        int size = n;
        while(size &gt; 1 &amp;&amp; b[1] &lt;= b[size]) size --; 
        swap(b[1],b[size --]);
        down(1,size);
    &#125;
    cout &lt;&lt; b[1];
    for(int i = 2;i &lt;= n;i ++) cout &lt;&lt; &#39; &#39; &lt;&lt; b[i];
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E6%8E%92%E5%BA%8F/" style="color: #00a596">排序</a>
        </span>
        
    </div>
    <a href="/2022/11/05/%E6%8F%92%E5%85%A5%E8%BF%98%E6%98%AF%E5%A0%86%E6%8E%92%E5%BA%8F/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/27/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/">
        <h2 class="post-title">对称的二叉树</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/9/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/38/">https://www.acwing.com/problem/content/38/</a><br> <p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p></p>
<p>如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<h4>数据范围</h4>
<p>树中节点数量 $[0,100]$。</p>
<h4>样例</h4>
<pre><code>如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：
    1
   / \
  2   2
 / \ / \
3  4 4  3

<p>如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：<br>    1<br>   &#x2F; <br>  2   2<br>   \ &#x2F; <br>   4 4  3<br></code></pre></p>
<p>$O(n)递归写法$<br>一棵树是对称二叉树，<strong>当且仅当</strong>，两颗子树的根节点相等，第一棵子树的左子树和第二棵子树的右子树互相对称，且第一棵子树的右子树和第二棵子树的左子树互相对称。<br><strong>递归是一个很巧妙的思路，感觉对于很多问题的处理，只要是存在子集的结构，都可以使用递归的思想（注：空集的子集是它本身，所以只要是一个集合，都会有子集的概念，这也就使得递归和分治成为一种很普遍的思想）</strong><br>本题看了y总写的，比较妙的一点是对于状态的判断的处理，省下了很多if()语句，但是直接理解起来有点难，遂加上注释以助于理解(核心在于返回的对象可以是一个表达式)</p>
<pre><code class="C++">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    bool isSymmetric(TreeNode* root) &#123;
        return !root || dfs(root-&gt;left,root-&gt;right);//如果根是空节点返回true，如果不空，递归到左右子树，如果对称也返回true。
    &#125;
    bool dfs(TreeNode* p,TreeNode* q)&#123;
        if(!p || !q) return !p &amp;&amp; !q;//如果两个节点有一个为空，那么两个节点都为空才返回true
        //否则
        return p-&gt;val == q-&gt;val &amp;&amp; dfs(p-&gt;left,q-&gt;right) &amp;&amp; dfs(p-&gt;right,q-&gt;left);//只有两个根节点值相等，且子树对称，才返回true。
    &#125;
    
&#125;;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/LeetCode/" style="color: #03a9f4">LeetCode</a>
        </span>
        
    </div>
    <a href="/2022/09/27/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/26/%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF/">
        <h2 class="post-title">通信线路</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/9/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/342/">https://www.acwing.com/problem/content/342/</a></p>
<p>在郊区有 $N$ 座通信基站，$P$ 条 <strong>双向</strong> 电缆，第 $i$ 条电缆连接基站 $A_i$ 和 $B_i$。</p>
<p>特别地，$1$ 号基站是通信公司的总站，$N$ 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 $i$ 条电缆需要花费 $L_i$。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 $1$ 号基站到 $N$ 号基站的路径，并指定路径上不超过 $K$ 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<h4>输入格式</h4>
<p>第 $1$ 行：三个整数 $N，P，K$。</p>
<p>第 $2..P+1$ 行：第 $i+1$ 行包含三个整数 $A_i,B_i,L_i$。</p>
<h4>输出格式</h4>
<p>包含一个整数表示最少花费。</p>
<p>若 $1$ 号基站与 $N$ 号基站之间不存在路径，则输出 $-1$。</p>
<h4>数据范围</h4>
<p>$0 \le K &lt; N \le 1000$,<br />
$1 \le P \le 10000$,<br />
$1 \le L_i \le 1000000$</p>
<h4>输入样例：</h4>
<pre><code>5 7 1
1 2 5
3 1 4
2 4 8
3 2 3
5 2 9
3 4 7
4 5 6
</code></pre>

<h4>输出样例：</h4>
<pre><code>4
</code></pre>

<p><strong>1：</strong>这里一条路径的权值定义为路径当中的第k + 1大值。<br>    我们要求第k + 1大值最小，求一个什么什么最小，<strong>可以很自然想到二分</strong>。<br>    想用二分要证明，看是否能找到一个性质满足以答案为基点划分，使得区间左右一个命题为真，一个命题为假。<br>    这里我们分析限制条件，来用作命题：<strong>是否存在一个x，<em>使得存在这样一条路径_：_从1走到n，经过大于等于x的边的数量小于等于k</em></strong></p>
<p><strong>2：</strong>接下来我们的问题变成了：**<em>给定一个权值x，如何测得是否存在一条路径，使得路径中边权值大于等于x的边的数量小于等于K。</em>**<br>    直接在图里面跑一遍最短路，重新**<em>记边权大于等于x的边的边权为1，否则为0</em><strong>.求一个</strong>最少<strong>大于等于边权x的边的数量。<br>    求出来之后，就算是</strong>求出来了一条1~n的路径**。满足该路径下，边权大于等于x的边的数量小于等于k。</p>
<p><strong>3：</strong>一点疑惑：同样都是<strong>“要求出来一条路径”</strong>，为什么我们挑选<strong>“这样的边最少的路径”</strong>也符合答案呢？（毕竟跑的是最短路径）如果稍微扰动一下，考虑另外一条路径B，这里的大于x的边的数量稍微多一些，会怎么样？<br>我们刚才求出来的是“最少的边数”小于等于k，稍微大一点了，可能仍然小于等于k啊。<br><strong>3.1</strong>解答：确实是这样。但是回头看看<strong>我们要证明的是一个存在性性质</strong>。<strong>只要说明有一条就好了</strong>，这样的话我们就找最短路径就OK。</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 1010,M = 20010;
int n,p,k;
int h[N],e[M],ne[M],w[M],idx;
deque&lt;int&gt; q;
int dist[N];
bool st[N];
void add(int a,int b,int c)
&#123;
    e[idx] = b,ne[idx] = h[a],w[idx] = c,h[a] = idx ++;
&#125;
bool check(int x)
&#123;
    memset(dist,0x3f,sizeof dist);
    memset(st,0,sizeof st);
    q.push_back(1);
    dist[1] = 0;
    while(q.size())
    &#123;
        auto t = q.front();
        q.pop_front();
        if(st[t]) continue;
        st[t] = true;
        for(int i = h[t];~i;i = ne[i])
        &#123;
            int j = e[i],weight = w[i] &gt; x;
            if(dist[j] &gt; dist[t] + weight)
            &#123;
                dist[j] = dist[t] + weight;
                if(!weight) q.push_front(j);
                else q.push_back(j);
            &#125;
            
        &#125;
    &#125;
    return dist[n] &lt;= k;
&#125;
int main()
&#123;
    cin &gt;&gt; n &gt;&gt; p &gt;&gt; k;
    memset(h,-1,sizeof h);
    for(int i = 0;i &lt; p;i ++)
    &#123;
        int a,b,c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a,b,c),add(b,a,c);
    &#125;
    int l = 0,r = 1e6 + 1;//设置r为1e6+1是为了辨析两种情况：出现不存在“最小值”的情况返回1e6+1，如果最小值就是1e6那就返回1e6
    while(l &lt; r)
    &#123;
        int mid = l + r &gt;&gt; 1;
        if(check(mid))  r = mid;
        else l = mid + 1;
    &#125;
    if(l == 1e6 + 1) printf(&quot;-1&quot;);
    else printf(&quot;%d&quot;,l);
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="color: #ffa2c4">图论</a>
        </span>
        
    </div>
    <a href="/2022/09/26/%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/08/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E8%AE%B2%E4%B9%89/">
        <h2 class="post-title">考研算法笔试讲义</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AF%95%E8%AE%B2%E4%B9%89/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                考研笔试讲义
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/8/13
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>AcWing《考研算法辅导课》讲义<br>考纲：<br>一、线性表<br>    （一）线性表的定义和基本操作<br>    （二）线性表的实现<br>        1. 顺序存储<br>        2. 链式存储<br>        3. 线性表的应用<br>二、栈、队列和数组<br>    （一）栈和队列的基本概念<br>    （二）栈和队列的顺序存储结构<br>    （三）栈和队列的链式存储结构<br>    （四）栈和队列的应用<br>    （五）特殊矩阵的存储和压缩<br>三、树与二叉树<br>    （一）树的基本概念<br>    （二）二叉树<br>        1. 二叉树的定义及其主要特征<br>        2. 二叉树的顺序存储结构和链式存储结构<br>        3. 二叉树的遍历<br>        4. 线索二叉树的基本概念和构造<br>    （三）树、森林<br>        1. 树的存储结构<br>        2. 森林与二叉树的转换<br>        3. 树和森林的遍历<br>    （四）树与二叉树的应用<br>        1. 二叉排序树<br>        2. 平衡二叉树<br>        3. 哈夫曼（Huffman）树的哈弗曼编码<br>四、图<br>    （一）图的基本概念<br>    （二）图的存储及基本操作<br>        1. 邻接矩阵法<br>        2. 邻接表法<br>        3. 邻接多重表、十字链表<br>    （三）图的遍历<br>        1. 深度优先搜索<br>        2. 广度优先搜索<br>    （四）图的基本应用<br>        1. 最小（代价）生成树<br>        2. 最短路径<br>        3. 拓扑排序<br>        4. 关键路径<br>五、查找<br>    （一）查找的基本概念<br>    （二）顺序查找法<br>    （三）分块查找法<br>    （四）折半查找法<br>    （五）B树及其基本操作、B+树及其基本概念<br>    （六）散列（Hash）表<br>    （七）字符串模式匹配（KMP）<br>    （八）查找算法的分析及应用<br>六、排序<br>    （一）排序的基本概念<br>    （二）插入排序<br>        1. 直接插入排序<br>        2. 折半插入排序<br>    （三）起泡排序（bubble sort）<br>    （四）简单选择排序<br>    （五）希尔排序（shell sort）<br>    （六）快速排序<br>    （七）堆排序<br>    （八）二路归并排序（merge sort）<br>    （九）基数排序<br>    （十）外部排序<br>    （十一）各种内部排序算法的比较<br>    （十二）排序算法的应用</p>
<hr>
<p>第1讲 时间复杂度、矩阵展开<br>一、时间、空间复杂度<br>    只考虑次数，不考虑常数。常见复杂度有：O(1)、O(n)、O(sqrt(n))、O(n^k)、O(logn)、O(nlogn)<br>    考题：2011-1、2012-1、2013-1、2014-1、2017-1、2019-1<br>二、矩阵展开<br>    矩阵的按行展开、按列展开，展开后下标从0开始。<br>    考题：2016-4、2018-3、2020-1</p>
<hr>
<p>第2讲 线性表</p>
<ol>
<li>将具有线性关系的数据存储到计算机中所使用的存储结构称为线性表。</li>
<li>对于线性表中的数据来说，位于当前数据之前的数据统称为“前趋元素”，前边紧挨着的数据称为“直接前趋”；同样，后边的数据统称为“后继元素”，后边紧挨着的数据称为“直接后继”。</li>
<li>线性表的分类<br> (1) 数据元素在内存中集中存储，采用顺序表示结构，简称“顺序存储”；<br> 例如：数组<br> (2) 数据元素在内存中分散存储，采用链式表示结构，简称“链式存储”。<br> 例如：单链表、双链表、循环单（双）链表</li>
<li>不同实现方式的时间复杂度（不要硬背结论、要从实现方式入手分情况讨论，下述为特定情况下的时间复杂度）<br> (1) 数组：随机索引O(1)、插入O(n)、删除O(n)<br> (2) 单链表：查找某一元素O(n)、插入O(1)、删除O(n)<br> (3) 双链表：查找某一元素O(n)、插入O(1)、删除O(1)</li>
<li>考题：2016-1、2016-2、2012-42、2015-41、2019-41</li>
<li>押题：AcWing 34、AcWing 1451</li>
</ol>
<hr>
<p>第3讲 栈与队列</p>
<ol>
<li>栈和队列的基本概念</li>
<li>栈和队列的顺序存储结构<br> (1) 栈：栈顶元素位置：指向最后一个元素、指向最后一个元素的下一个位置<br> (2) 队列：一般采用循环队列。<br> (a) 队头元素位置：指向第一个元素、指向第一个元素的前一个位置。<br> (b) 队尾元素位置：指向队尾元素、指向队尾元素的下一个位置。</li>
<li>栈和队列的链式存储结构</li>
<li>栈和队列的应用<br> (1) 栈的应用：表达式求值（中缀表达式转后缀表达式、括号匹配）、DFS<br> (2) 队列的应用：BFS</li>
<li>考题：2011-2、2011-3、2012-2、2013-2、2014-2、2014-3、2015-1、2016-3、2017-2、2018-1、2018-2、2019-42、2020-2</li>
<li>押题：AcWing 3302</li>
</ol>
<hr>
<p>第4讲 树的基本概念、二叉树、树和森林</p>
<ol>
<li>树的基本概念<br> (1) 树是由根节点和若干颗子树构成的。树是由一个集合以及在该集合上定义的一种关系构成的。集合中的元素称为树的节点，所定义的关系称为父子关系。父子关系在树的节点之间建立了一个层次结构。在这种层次结构中有一个节点具有特殊的地位，这个节点称为该树的根节点，或称为树根。<br> (2) 空集合也是树，称为空树。空树中没有节点；<br> (3) 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；<br> (4) 节点的度：一个节点含有的子节点的个数称为该节点的度；<br> (5) 叶节点或终端节点：度为0的节点称为叶节点；<br> (6) 非终端节点或分支节点：度不为0的节点；<br> (7) 双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；<br> (8) 兄弟节点：具有相同父节点的节点互称为兄弟节点；<br> (9) 树的度：一棵树中，最大的节点的度称为树的度；<br> (10) 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；<br> (11) 树的高度或深度：树中节点的最大层次；<br> (12) 节点的祖先：从根到该节点所经分支上的所有节点；<br> (13) 子孙：以某节点为根的子树中任一节点都称为该节点的子孙；<br> (14) 森林：由棵互不相交的树的集合称为森林。</li>
<li>二叉树<br> (1) 二叉树的定义及其主要特征<br> a. 二叉树的基本形态：空二叉树、单节点二叉树、左子树、右子树<br> b. 性质：<br>     [1] 在非空二叉树中，第i层上至多有2^(i-1) 个结点。<br>     [2] 深度为k的二叉树至多有2^k - 1个结点<br>     [3] 对任何一棵二叉树，若其叶子结点数为n0，度为2的结点数为n2，则n0 &#x3D; n2 + 1。<br>     [4] n个结点的完全二叉树深度为：log2(n)向下取整 + 1<br>     [5] 二叉树的堆式存储: 节点p的左儿子：2x，右儿子：2x+1<br> c. 两种特殊的二叉树<br>     [1] 满二叉树：一颗深度为k且有2^k-1个结点的二叉树<br>     [2] 如果深度为k,有n个结点的二叉树，当且仅当其每个结点都与深度为k的满二叉树中编号从1到n的结点一一对应，该二叉树称为完全二叉树<br> (2) 二叉树的顺序存储结构和链式存储结构<br> (3) 二叉树的遍历<br> a. 前序遍历<br> b. 中序遍历<br> c. 后序遍历<br> d. 根据前序 + 中序重建二叉树（AcWing 18)<br> (4) 线索二叉树的基本概念和构造<br> 对二叉树节点的指针域做如下规定：<br>     a. 若节点有左孩子，则Lchild指向左孩子，否则指向直接前驱；右孩子同理；<br>     b. 增加两个标志域，Ltag表示指向的是子节点还是前驱；Rtag同理<br>     c. 指向前驱和后继的指针叫做线索。按照某种次序遍历，加上线索的二叉树称之为线索二叉树</li>
<li>树、森林<br> (1) 树的存储结构<br> a. 只存父节点<br> b. 邻接表存储所有子节点<br> c. 左儿子右兄弟<br> (2) 森林F与二叉树T的转换<br> a. 原树中叶子节点数 &#x3D; 转换后的树中有右儿子的节点数 + 1<br> b. F的前序遍历就是T的前序遍历<br> c. F的后序遍历就是T的中序遍历<br> (3) 树和森林的遍历<br> a. 前序遍历<br> b. 后序遍历</li>
<li>考题：2011-4、2011-5、2011-6、2012-3、2013-5、2014-4、2014-5、2014-41、2015-2、2016-5、2016-42、2017-4、2017-5、2018-4、2019-2、2020-3、2020-4</li>
<li>押题：AcWing 18、AcWing 19</li>
</ol>
<hr>
<p>第5讲 二叉排序树、平衡树、表达式树</p>
<ol>
<li>二叉排序树</li>
<li>平衡树——AVL<br> (1) 定义：满足如下条件的树：<br> a. 是二叉查找树<br> b. 每个节点的左子树和右子树的高度差最多为1<br> (2) 平衡因子：一个结点的左子树的高度减去右子树的高度，可取-1、0、1三种值<br> (3) 平衡操作</li>
<li>表达式树</li>
<li>考题：2011-7、2012-4、2013-3(PDF中的分析有误，以上课讲解为准)、2013-6、2015-4、2018-6、2019-4、2019-6、2020-5、2017-41</li>
</ol>
<hr>
<p>第6讲 Huffman编码和Huffman树</p>
<ol>
<li>Huffman编码和Huffman树<br> (1) Huffman编码<br> a. 前缀编码: 是指对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀。<br> b. 树的带权路径长度(WPL)<br> c. 构造过程<br> (2) Huffman树<br> (3) 应用</li>
<li>考题：2012-41、2013-4、2014-6、2015-3、2017-6、2018-5、2019-3、2020-42</li>
</ol>
<hr>
<p>第7讲 图的基本概念、存储、遍历、拓扑排序</p>
<ol>
<li>图的基本概念<br> (1) 有向图、无向图<br> (2) 度数（出度、入度）<br> (3) 简单图：不存在顶点到其自身的边，且同一条边不重复出现<br> (4) 路径、环、简单路径<br> (5) 无向完全图：任意两个顶点之间都存在边，有n个顶点的无向完全图有 n × (n - 1) &#x2F; 2条边<br> (6) 有向完全图：任意两个顶点之间都存在方向护卫相反的两条弧，有n个顶点的无向完全图有 n × (n - 1) 条弧<br> (7) 稀疏图&amp;稠密图：有很少条边或弧的图称为稀疏图，反之称为稠密图，相对的概念。</li>
<li>图的存储及基本操作<br> (1) 邻接矩阵：适用于稠密图，可存有向图、无向图。常用。空间复杂度：O(n^2)。无法存重边。<br> (2) 邻接表：适用于稀疏图，可存有向图、无向图。常用。空间复杂度：O(n + m)。可存重边。<br> (3) 邻接多重表，适用于稀疏图，可存无向图。不常用。空间复杂度：O(n + m)。可存重边。<br> (4) 十字链表，适用于稀疏图，可存有向图、无向图。不常用。空间复杂度：O(n + m)。无法存重边<br> (5) 三元组表，适用于稀疏图，可存有向图，无向图。常用于Bellman-Ford算法、Kruskal算法。空间复杂度：O(m)。可存重边。</li>
<li>图的遍历<br> (1) 深度优先搜索。邻接表存储的时间复杂度：O(n + m)。邻接矩阵存储的时间复杂度：O(n^2)<br> (2) 广度优先搜索。邻接表存储的时间复杂度：O(n + m)。邻接矩阵存储的时间复杂度：O(n^2)</li>
<li>拓扑排序</li>
<li>考题：2011-8、2012-5、2012-6、2013-7、2013-8、2014-7、2015-5、2016-6、2016-7、2017-3、2017-7、2018-7、2020-6</li>
</ol>
<hr>
<p>第8讲 最小生成树、最短路、关键路径</p>
<ol>
<li>最小生成树<br> (1) Prim<br> (2) Kruskal</li>
<li>最短路<br> (1) 单源最短路 Dijkstra<br> (2) 多源汇最短路 Floyd</li>
<li>关键路径</li>
<li>考题：2011-41、2012-7、2012-8、2013-9、2015-6、2015-42、2016-8、2017-42、2018-42、2019-5、2020-7、2020-8</li>
</ol>
<hr>
<p>第9讲 基本概念、顺序、折半、分块查找法、B&#x2F;B+树</p>
<ol>
<li>查找的基本概念<br> (1) 平均查找长度 ASL &#x3D; 每个元素 查找概率 * 找到第i个元素需要进行的比较次数 的和。<br> (2) 决策树(判定树)</li>
<li>顺序查找法<br> (1) 一般线性表的顺序查找<br> a. 若每个元素查找概率相同，则 ASL(成功) &#x3D; (1 + 2 + … + n) &#x2F; n &#x3D; (n + 1) &#x2F; 2<br> b. ASL(失败) &#x3D; n或n+1，取决于代码写法。<br> (2) 有序表的顺序查找<br> a. 若每个元素查找概率相同，则 ASL(成功) &#x3D; (1 + 2 + … + n) &#x2F; n &#x3D; (n + 1) &#x2F; 2<br> b. ASL(失败) &#x3D; (1 + 2 + … + n + n) &#x2F; (n + 1) &#x3D; n &#x2F; 2 + n &#x2F; (n + 1)</li>
<li>折半查找法<br> (1) ASL &#x3D; log(n + 1) - 1</li>
<li>分块查找法<br> 设共n个元素，每块s个元素，共b &#x3D; n &#x2F; s块。块内无序，块间有序。<br> (1) 顺序查找确定块：ASL(成功) &#x3D; (s^2 + 2s + n) &#x2F; (2s)，s &#x3D; sqrt(n)时取最小值<br> (2) 二分查找确定块：log(n&#x2F;s + 1) + (s - 1)&#x2F;2</li>
<li>B树及其基本操作、B+树及其基本概念<br> (1) B树<br> [1] m阶B树，每个节点最多有m个孩子。<br> [2] 每个节点最多有m-1个关键字（可以存有的键值对）。<br> [3] 根节点最少可以只有1个关键字。<br> [4] 非根节点至少有m&#x2F;2个关键字。<br> [5] 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。<br> [6] 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。<br> [7] 每个节点都存有索引和数据，也就是对应的key和value。<br> [8] 所以，根节点的关键字数量范围：1 &lt;&#x3D; k &lt;&#x3D; m-1，非根节点的关键字数量范围：m&#x2F;2 &lt;&#x3D; k &lt;&#x3D; m-1。<br> (2) B+树<br> [1] B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；<br> [2] B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；<br> [3] B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。<br> (3) 参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Fmuma/article/details/80287924">https://blog.csdn.net/Fmuma/article/details/80287924</a></li>
<li>考题：2011-42、2012-9、2013-10、2013-42、2014-9、2015-7、2016-9、2016-10、2017-8、2017-9、2018-8、2020-10</li>
</ol>
<hr>
<p>第10讲 散列（Hash）表、字符串模式匹配（KMP）</p>
<ol>
<li>散列（Hash）表<br> (1) 负载因子<br> (2) 哈希函数<br> [1] 除余法 h(x) &#x3D; x % M<br> [2] 乘余取整法 h(x) &#x3D; floor(n * (A * x的小数部分))<br> [3] 平方取中法 先平方，然后取中间几位<br> [4] 基数转换法 换成其他进制，然后取其中几位<br> [5] ELFhash字符串<br> (3) 解决冲突的方式<br> [1] 开散列方法（拉链法）<br> [2] 闭散列方法（开放寻址法）<br>     聚集和二级聚集<br>     a. 线性探查法 d(i) &#x3D; (d(0) + i * c) % M。易产生聚集问题。<br>     b. 二次探查法。易产生二级聚集问题。<br>         d(2i - 1) &#x3D; (d(0) + i^2) % M<br>         d(2i) &#x3D; (d(0) - d ^2) % M<br>     c. 随机探查法。易产生二级聚集问题。<br>     d. 双散列探查法</li>
<li>字符串模式匹配（KMP）</li>
<li>考题：2011-9、2014-8、2015-8、2018-9、2018-41、2019-8、2019-9</li>
</ol>
<hr>
<p>第11讲 基本概念、插入、冒泡、选择、希尔、快速、堆、归并排序</p>
<ol>
<li>排序的基本概念<br> (1) 内排序和外排序<br> (2) 算法的稳定性</li>
<li>插入排序<br> (1) 直接插入排序<br> a. 时间复杂度<br>     [1] 最好情况：O(n)<br>     [2] 平均情况：O(n^2)<br>     [3] 最坏情况：O(n^2)<br> b. 辅助空间复杂度<br>     O(1)<br> c. 稳定<br> (2) 折半插入排序<br> a. 时间复杂度<br>     [1] 最好情况：O(n)<br>     [2] 平均情况：O(n^2)<br>     [3] 最坏情况：O(n^2)<br> b. 辅助空间复杂度<br>     O(1)<br> c. 稳定</li>
<li>冒泡排序（bubble sort）<br> (1) 时间复杂度<br> a. 最好情况：O(n)<br> b. 平均情况：O(n^2)<br> c. 最坏情况：O(n^2)<br> (2) 空间复杂度<br> O(1)<br> (3) 稳定</li>
<li>简单选择排序<br> (1) 时间复杂度<br> a. 最好情况：O(n^2)<br> b. 平均情况：O(n^2)<br> c. 最坏情况：O(n^2)<br> (2) 空间复杂度<br> O(1)<br> (3) 不稳定</li>
<li>希尔排序（shell sort）<br> (1) 时间复杂度<br> O(n^(3&#x2F;2))<br> (2) 空间复杂度<br> O(1)<br> (3) 不稳定</li>
<li>快速排序<br> (1) 时间复杂度<br> a. 最好情况：O(nlogn)<br> b. 平均情况：O(nlogn)<br> c. 最坏情况：O(n^2)<br> (2) 空间复杂度<br> O(logn)<br> (3) 不稳定</li>
<li>堆排序<br> (1) 时间复杂度<br> a. 最好情况：O(nlogn)<br> b. 平均情况：O(nlogn)<br> c. 最坏情况：O(nlogn)<br> (2) 空间复杂度<br> O(logn)<br> (3) 不稳定</li>
<li>二路归并排序（merge sort）<br> (1) 时间复杂度<br> a. 最好情况：O(nlogn)<br> b. 平均情况：O(nlogn)<br> c. 最坏情况：O(nlogn)<br> (2) 空间复杂度<br> O(n)<br> (3) 稳定</li>
</ol>
<hr>
<p>第12讲 桶排序、基数排序、外部排序</p>
<ol>
<li>桶排序<br> (1) 时间复杂度<br> a. 最好情况：O(n + m)<br> b. 平均情况：O(n + m)<br> c. 最坏情况：O(n + m)<br> (2) 空间复杂度<br> O(n + m)<br> (3) 稳定</li>
<li>基数排序<br> (1) 时间复杂度<br> a. 最好情况：O(d(n + r))<br> b. 平均情况：O(d(n + r))<br> c. 最坏情况：O(d(n + r))<br> (2) 空间复杂度<br> O(n + r)<br> (3) 稳定</li>
<li>外部排序<br> (1) 置换选择排序<br> (2) 归并排序<br> a. 胜者树<br> b. 败者树<br> c. huffman树</li>
<li>考题：2011-10、2011-11、2012-10、2012-11、2013-11、2014-10、2014-11、2015-9、2015-10、2015-11、2016-11、2016-43、2017-10、2017-11、2018-10、2018-11、2019-7、2019-10、2019-11、2020-9、2020-11、2020-41</li>
</ol>
<hr>
<p>第21讲 红黑树和并查集</p>
<ol>
<li><p>红黑树<br> 1.1 定义<br> (1) 结点是红色或黑色。<br> (2) 根结点是黑色。<br> (3) 所有叶子都是黑色。（叶子是NIL结点）<br> (4) 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）<br> (5) 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。<br> 1.2 性质<br> 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。<br> 1.3 平衡操作<br> 1.3.1 插入<br>     1.3.1.1 被插入的节点是根节点。<br>         直接把此节点涂为黑色。<br>     1.3.1.2 被插入的节点的父节点是黑色。<br>         什么也不需要做。<br>     1.3.1.3 被插入的节点的父节点是红色。<br>         [1] 当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。<br>             (1) 将“父节点”设为黑色。<br>             (2) 将“叔叔节点”设为黑色。<br>             (3) 将“祖父节点”设为“红色”。<br>             (4) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。<br>         [2] 叔叔节点是黑色，且当前节点是其父节点的右孩子<br>             (1) 将“父节点”作为“新的当前节点”。<br>             (2) 以“新的当前节点”为支点进行左旋。<br>         [3] 叔叔节点是黑色，且当前节点是其父节点的左孩子<br>             (1) 将“父节点”设为“黑色”。<br>             (2) 将“祖父节点”设为“红色”。<br>             (3) 以“祖父节点”为支点进行右旋。<br> 1.3.2 删除<br>     1.3.2.1 x指向一个”红+黑”节点。<br>         将x设为一个”黑”节点即可。<br>     1.3.2.2 x指向根。<br>         将x设为一个”黑”节点即可。<br>     1.3.2.3<br>         [1] x的兄弟节点是红色。<br>             (1) 将x的兄弟节点设为“黑色”。<br>             (2) 将x的父节点设为“红色”。<br>             (3) 对x的父节点进行左旋。<br>             (4) 左旋后，重新设置x的兄弟节点。<br>         [2] x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。<br>             (1) 将x的兄弟节点设为“红色”。<br>             (2) 设置“x的父节点”为“新的x节点”。<br>         [3] x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。<br>             (1) 将x兄弟节点的左孩子设为“黑色”。<br>             (2) 将x兄弟节点设为“红色”。<br>             (3) 对x的兄弟节点进行右旋。<br>             (4) 右旋后，重新设置x的兄弟节点。<br>         [4] x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。<br>             (1) 将x父节点颜色 赋值给 x的兄弟节点。<br>             (2) 将x父节点设为“黑色”。<br>             (3) 将x兄弟节点的右子节设为“黑色”。<br>             (4) 对x的父节点进行左旋。
     
             </p>
</li>
<li><p>并查集<br> 2.1 定义<br> 用森林维护集合关系，支持合并、查询等操作。<br> 2.2 优化<br> (1) 路径压缩<br> (2) 按秩合并</p>
</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E7%AC%94%E8%AF%95%E8%AE%B2%E4%B9%89/" style="color: #ff7d73">笔试讲义</a>
        </span>
        
    </div>
    <a href="/2022/08/13/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AF%95%E8%AE%B2%E4%B9%89/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/08/01/pointer/">
        <h2 class="post-title">What is a pointer?</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                计算机知识
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/8/1
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>先贴一个解释指针很好的博客<a href="https://">https://www.cnblogs.com/zhangrxiang/articles/8465678.html</a> </p>
<hr>
<p>再分享一篇看到的文章：<br><strong>本文从编译器的角度解释了变量即对象，解析了变量的rvalue和lvalue，从lvalue的角度引出了对指针的看法</strong></p>
<hr>
<p><strong><em>One of those things beginners in C find difficult is the concept of pointers. The purpose of this tutorial is to provide an introduction to pointers and their use to these beginners.One of those things beginners in C find difficult is the concept of pointers. The purpose of this tutorial is to provide an introduction to pointers and their use to these beginners.</em></strong></p>
<p><strong><em>I have found that often the main reason beginners have a problem with pointers is that they have a weak or minimal feeling for variables, (as they are used in C). Thus we start with a discussion of C variables in general.</em></strong></p>
<p><strong><em>A variable in a program is something with a name, the value of which can vary. The way the compiler and linker handles this is that it assigns a specific block of memory within the computer to hold the value of that variable. The size of that block depends on the range over which the variable is allowed to vary. For example, on 32 bit PC’s the size of an integer variable is 4 bytes. On older 16 bit PCs integers were 2 bytes.  In C the size of a variable type such as an integer need not be the same on all types of machines.  Further more there is more than one type of integer variable in C.  We have integers, long integers and short integers which you can read up on in any basic text on C.  This document assumes the use of a 32 bit system with 4 byte integers.</em></strong></p>
<p><strong><em>If you want to know the size of the various types of integers on your system, running the following code will give you that information.</em></strong></p>
<pre><code class="C++">#include &lt;stdio.h&gt;

int main()
&#123;
printf(&quot;size of a short is %d\n&quot;, sizeof(short));
printf(&quot;size of a int is %d\n&quot;, sizeof(int));
printf(&quot;size of a long is %d\n&quot;, sizeof(long));
&#125;
</code></pre>
<hr>
<p><strong><em>When we declare a variable we inform the compiler of two things, the name of the variable and the type of the variable. For example, we declare a variable of type integer with the name k by writing:</em></strong></p>
<pre><code>int k; 
</code></pre>
<p>**<em>On seeing the “int” part of this statement the compiler sets aside 4 bytes of memory (on a PC) to hold the value of the integer. It also sets up a symbol table. In that table it adds the symbol k and the relative address in memory where those 4 bytes were set aside.</em>**（变量的构成）</p>
<p><strong><em>Thus, later if we write:</em></strong></p>
<pre><code>k = 2; 
</code></pre>
<p>**<em>we expect that, at run time when this statement is executed, the value 2 will be placed in that memory location reserved for the storage of the value of k. In C we refer to a variable such as the integer k as an “object”.</em> **（在C中，变量，即可以看作一个对象）</p>
<hr>
<p>对于一个对象的加深理解：一个对象具有两个值(“are value” 和 “lvalue”)<br><strong><em>In a sense there are two “values” associated with the object k. One is the value of the integer stored there (2 in the above example) and the other the “value” of the memory location, i.e., the address of k. Some texts refer to these two values with the nomenclature rvalue (right value, pronounced “are value”) and lvalue (left value, pronounced “el value”) respectively.</em></strong></p>
<p><strong><em>In some languages, the lvalue is the value permitted on the left side of the assignment operator ‘&#x3D;’ (i.e. the address where the result of evaluation of the right side ends up). The rvalue is that which is on the right side of the assignment statement, the 2 above. Rvalues cannot be used on the left side of the assignment statement. Thus: 2 &#x3D; k; is illegal.</em></strong></p>
<p><strong><em>Actually, the above definition of “lvalue” is somewhat modified for C. According to K&amp;R II (page 197): [1]</em></strong></p>
<p><strong><em>“An object is a named region of storage; an lvalue is an expression referring to an object.”</em></strong><br>(对象是命名的存储区域；左值是对“对象引用”的表达)<br><strong><em>However, at this point, the definition originally cited above is sufficient. As we become more familiar with pointers we will go into more detail on this.</em></strong></p>
<p><strong><em>Okay, now consider:</em></strong></p>
<pre><code class="C++">   int j, k; 

    k = 2; 
    j = 7;    &lt;-- line 1 
    k = j;    &lt;-- line 2 
</code></pre>
<p>（从编译器的角度解释变量(object)，提出address的必要性）<br><strong><em>In the above, the compiler interprets the j in line 1 as the address of the variable j (its lvalue) and creates code to copy the value 7 to that address. In line 2, however, the j is interpreted as its rvalue (since it is on the right hand side of the assignment operator ‘&#x3D;’). That is, here the j refers to the value stored at the memory location set aside for j, in this case 7. So, the 7 is copied to the address designated by the lvalue of k.</em></strong></p>
<p><strong><em>In all of these examples, we are using 4 byte integers so all copying of rvalues from one storage location to the other is done by copying 4 bytes. Had we been using two byte integers, we would be copying 2 bytes.</em></strong></p>
<hr>
<p>（引出了指针的概念）：得到对象的左值</p>
<p><strong><em>Now, let’s say that we have a reason for wanting a variable designed to hold an lvalue (an address). The size required to hold such a value depends on the system. On older desk top computers with 64K of memory total, the address of any point in memory can be contained in 2 bytes. Computers with more memory would require more bytes to hold an address.  The actual size required is not too important so long as we have a way of informing the compiler that what we want to store is an address.</em></strong></p>
<p><strong><em>Such a variable is called a pointer variable (for reasons which hopefully will become clearer a little later). In C when we define a pointer variable we do so by preceding its name with an asterisk. In C we also give our pointer a type which, in this case, refers to the type of data stored at the address we will be storing in our pointer. For example, consider the variable declaration:</em></strong></p>
<pre><code>int *ptr;
</code></pre>
<p>(核心句：However many bytes is required to store an address in memory)<br><strong><em>ptr is the name of our variable (just as k was the name of our integer variable). The ‘*’ informs the compiler that we want a pointer variable, i.e. to set aside however many bytes is required to store an address in memory. 《The int says that we intend to “use our pointer variable（工具人）” to store the address of an integer. Such a pointer is said to “point to” an integer.（打工人） 》However, note that when we wrote int k; we did not give k a value. If this definition is made outside of any function ANSI compliant compilers will initialize it to zero. Similarly, ptr has no value, that is we haven’t stored an address in it in the above declaration. In this case, again if the declaration is outside of any function, it is initialized to a value guaranteed in such a way that it is guaranteed to not point to any C object or function. A pointer initialized in this manner is called a “null” pointer.</em></strong></p>
<hr>
<p>（对于空指针的定义不同系统是不一样的，不一定都是“0”，但是无论如何我们把<strong>空指针用宏写成NULL</strong>，就可以方便代码做移植，这里做了一层抽象）</p>
<p><strong><em>The actual bit pattern used for a null pointer may or may not evaluate to zero since it depends on the specific system on which the code is developed. To make the source code compatible between various compilers on various systems, a macro is used to represent a null pointer. That macro goes under the name NULL. Thus, setting the value of a pointer using the NULL macro, as with an assignment statement such as ptr &#x3D; NULL, guarantees that the pointer has become a null pointer. Similarly, just as one can test for an integer value of zero, as in if(k &#x3D;&#x3D; 0), we can test for a null pointer using if (ptr &#x3D;&#x3D; NULL).</em></strong></p>
<p><strong><em>But, back to using our new variable ptr. Suppose now that we want to store in ptr the address of our integer variable k. To do this we use the unary（单元运算符） &amp; operator and write:</em></strong></p>
<pre><code>ptr = &amp;k; 
</code></pre>
<p><strong><em>What the &amp; operator does is retrieve the lvalue (address) of k, even though k is on the right hand side of the assignment operator ‘&#x3D;’, and copies that to the contents of our pointer ptr. Now, ptr is said to “point to” k. Bear with us now, there is only one more operator we need to discuss.</em></strong></p>
<p><strong><em>The “dereferencing operator”(解引用) is the asterisk and it is used as follows:</em></strong></p>
<pre><code>*ptr = 7; 
</code></pre>
<p><strong><em>will copy 7 to the address pointed to by ptr. Thus if ptr “points to” (contains the address of) k, the above statement will set the value of k to 7. That is, when we use the ‘*’ this way we are referring to the value of that which ptr is pointing to, not the value of the pointer itself.</em></strong></p>
<p><strong><em>Similarly, we could write:</em></strong></p>
<pre><code> printf(&quot;%d\n&quot;,*ptr); 
</code></pre>
<p><strong><em>to print to the screen the integer value stored at the address pointed to by ptr;.</em></strong></p>
<p><strong><em>One way to see how all this stuff fits together would be to run the following program and then review the code and the output carefully.</em></strong></p>
<p>———— Program 1.1 ———————————</p>
<pre><code class="C++"> 1 /* Program 1.1 from PTRTUT10.TXT   6/10/97 */
 2 
 3 #include &lt;stdio.h&gt;
 4 
 5 int j, k;
 6 int *ptr;
 7 
 8 int main(void)
 9 &#123;
10     j = 1;
11     k = 2;
12     ptr = &amp;k;
13     printf(&quot;\n&quot;);
14     printf(&quot;j has the value %d and is stored at %p\n&quot;, j, (void *)&amp;j);
15     printf(&quot;k has the value %d and is stored at %p\n&quot;, k, (void *)&amp;k);
16     printf(&quot;ptr has the value %p and is stored at %p\n&quot;, ptr, (void *)&amp;ptr);
17     printf(&quot;The value of the integer pointed to by ptr is %d\n&quot;, *ptr);
18 
19     return 0;
20 &#125;
</code></pre>
<p>**<em>Note: We have yet to discuss those aspects of C which require the use of the (void *) expression used here. For now, include it in your test code. We’ll explain the reason behind this expression later.</em>**</p>
<p><strong><em>To review:</em></strong></p>
<p><strong><em>A variable is declared by giving it a type and a name (e.g. int k;)</em></strong><br>**<em>A pointer variable is declared by giving it a type and a name (e.g. int *ptr) where the asterisk tells the compiler that the variable named ptr is a pointer variable and the type tells the compiler what type the pointer is to point to (integer in this case).</em>**<br><strong><em>Once a variable is declared, we can get its address by preceding its name with the unary &amp; operator, as in &amp;k.</em></strong><br>**<em>We can “dereference” a pointer, i.e. refer to the value of that which it points to, by using the unary ‘*’ operator as in *ptr.</em>**<br><strong><em>An “lvalue” of a variable is the value of its address, i.e. where it is stored in memory. The “rvalue” of a variable is the value stored in that variable (at that address).</em></strong><br><strong><em>References for Chapter 1:</em></strong><br><strong><em>“The C Programming Language” 2nd Edition</em></strong><br><strong>_B. Kernighan and D. Ritchie _</strong><br><strong>_Prentice Hall _</strong><br><strong><em>ISBN 0-13-110362-8 A variable is declared by giving it a type and a name (e.g. int k;)</em></strong><br><strong><em>A variable is declared by giving it a type and a name (e.g. int k;)</em></strong><br>**<em>A pointer variable is declared by giving it a type and a name (e.g. int *ptr) where the asterisk tells the compiler that the variable named ptr is a pointer variable and the type tells the compiler what type the pointer is to point to (integer in this case).</em>**</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86/" style="color: #00a596">语言知识</a>
        </span>
        
    </div>
    <a href="/2022/08/01/pointer/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/06/06/%E8%83%BD%E9%87%8F%E7%9F%B3/">
        <h2 class="post-title">能量石</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/6/6
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/736/">https://www.acwing.com/problem/content/736/</a></p>
<p>岩石怪物杜达生活在魔法森林中，他在午餐时收集了 $N$ 块能量石准备开吃。 </p>
<p>由于他的嘴很小，所以一次只能吃一块能量石。 </p>
<p>能量石很硬，吃完需要花不少时间。</p>
<p>吃完第 $i$ 块能量石需要花费的时间为 $S_i$ 秒。</p>
<p>杜达靠吃能量石来获取能量。 </p>
<p>不同的能量石包含的能量可能不同。 </p>
<p>此外，能量石会随着时间流逝逐渐失去能量。 </p>
<p>第 $i$ 块能量石最初包含 $E_i$ 单位的能量，并且每秒将失去 $L_i$ 单位的能量。 </p>
<p>当杜达开始吃一块能量石时，他就会立即获得该能量石所含的全部能量（无论实际吃完该石头需要多少时间）。 </p>
<p>能量石中包含的能量最多降低至 $0$。</p>
<p>请问杜达通过吃能量石可以获得的最大能量是多少？</p>
<h4>输入格式</h4>
<p>第一行包含整数 $T$，表示共有 $T$ 组测试数据。</p>
<p>每组数据第一行包含整数 $N$，表示能量石的数量。</p>
<p>接下来 $N$ 行，每行包含三个整数 $S_i,E_i,L_i$。</p>
<h3>输出格式</h3>
<p>每组数据输出一个结果，每个结果占一行。</p>
<p>结果表示为 <code>Case #x: y</code>，其中 $x$ 是组别编号（从 $1$ 开始），$y$ 是可以获得的最大能量值。</p>
<h4>数据范围</h4>
<p>$1 \le T \le 10$,<br />
$1 \le N \le 100$,<br />
$1 \le S_i \le 100$,<br />
$1 \le E_i \le 10^5$,<br />
$0 \le L_i \le 10^5$</p>
<h4>输入样例：</h4>
<pre><code>3
4
20 10 1
5 30 5
100 30 1
5 80 60
3
10 4 1000
10 3 1000
10 8 1000
2
12 300 50
5 200 0
</code></pre>

<h4>输出样例：</h4>
<pre><code>Case #1: 105
Case #2: 8
Case #3: 500
</code></pre>

<h4>样例解释</h4>
<p>在样例＃1中，有 $N = 4$ 个宝石。杜达可以选择的一个吃石头顺序是：</p>
<ul>
<li>吃第四块石头。这需要 $5$ 秒，并给他 $80$ 单位的能量。</li>
<li>吃第二块石头。这需要 $5$ 秒，并给他 $5$ 单位的能量（第二块石头开始时具有 $30$ 单位能量，$5$ 秒后失去了 $25$ 单位的能量）。</li>
<li>吃第三块石头。这需要 $100$ 秒，并给他 $20$ 单位的能量（第三块石头开始时具有 $30$ 单位能量，$10$ 秒后失去了 $10$ 单位的能量）。</li>
<li>吃第一块石头。这需要 $20$ 秒，并给他 $0$ 单位的能量（第一块石头以 $10$ 单位能量开始，$110$ 秒后已经失去了所有的能量）。</li>
</ul>
<p>他一共获得了 $105$ 单位的能量，这是能获得的最大值，所以答案是 $105$。</p>
<p>在样本案例＃2中，有 $N = 3$ 个宝石。</p>
<p>无论杜达选择吃哪块石头，剩下的两个石头的能量都会耗光。</p>
<p>所以他应该吃第三块石头，给他提供 $8$ 单位的能量。</p>
<p>在样本案例＃3中，有 $N = 2$ 个宝石。杜达可以：</p>
<ul>
<li>吃第一块石头。这需要 $12$ 秒，并给他 $300$ 单位的能量。</li>
<li>吃第二块石头。这需要 $5$ 秒，并给他 $200$ 单位的能量（第二块石头随着时间的推移不会失去任何能量！）。</li>
</ul>
<p>所以答案是 $500$。</p>

<p>本题一看像是01背包，但是有一点不一样的就是<strong>物品的价值是变化的</strong>，所以<strong>“考虑一个合理的顺序”对于这道题来说很重要</strong><br>    我们想要的目标是：<strong>我按一定顺序进食，得到的结果一定优于不按这个顺序进食的结果</strong><br>邻项交换：假设我们面对一个$Stone_i$和一个$Stone_{i+1}$，<strong>我们想要尝试构造的目标是“先吃i一定比先吃i+1要好”</strong><br>所以列出式子(令j &#x3D; i + 1)有：$$E_i+E_j−S_i×L_j≥E_j+E_i−S_j×L_i$$ $$S_j×L_i≥Si×L_j$$<br>所以说我们要按照这个公式，给所有物品排序，然后从前往后进食。按这样顺序进食的结果一定优于非这样顺序进食的结果(反证法可证)</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 10010,M = 110;
int T,n;
struct Stone
&#123;
    int s,e,l;
&#125;stone[M];
bool cmp(Stone a,Stone b)
&#123;
    int S = a.s, SS = b.s,L = a.l,LL = b.l;
    return S * LL &lt; SS * L;
&#125;
int f[N];

int main()
&#123;
    cin &gt;&gt; T;
    for(int C = 1;C &lt;= T;C ++)
    &#123;
        cin &gt;&gt; n;
        int m = 0;
        for(int i = 1;i &lt;= n;i ++)
        &#123;
            cin &gt;&gt; stone[i].s &gt;&gt; stone[i].e &gt;&gt; stone[i].l;
            m += stone[i].s;//记录下最多用多少时间方便下面决策
        &#125;
        
        sort(stone + 1,stone + n + 1,cmp);
        
        memset(f,-1,sizeof f);//把f[0][i]等都初始化成不可达的状态
        f[0] = 0;//起点为f[0]
        
        for(int i = 1;i &lt;= n;i ++)
        &#123;
            for(int j = m;j &gt;= stone[i].s;j --)
            &#123;
                int e = stone[i].e,l = stone[i].l,s = stone[i].s;
                f[j] = max(f[j],f[j - s] + e - l * (j - s));
            &#125;
        &#125;
        int res = 0;
        for(int j = 0;j &lt;= m;j ++) res = max(res,f[j]);
        printf(&quot;Case #%d: %d\n&quot;,C,res);
    &#125;
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="color: #00bcd4">动态规划</a>
        </span>
        
    </div>
    <a href="/2022/06/06/%E8%83%BD%E9%87%8F%E7%9F%B3/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/06/05/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/">
        <h2 class="post-title">无线网络</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/6/5
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/4432/">https://www.acwing.com/problem/content/4432/</a></p>
 <p>农夫约翰的农场可以看作一个二维平面。</p>
<p>农场中散布着 $n$ 头奶牛，每头奶牛的位置坐标已知。</p>
<p>农场中还建有 $2$ 个 wifi 基站，每个基站的位置坐标已知。</p>
<p>这 $n+2$ 个位置坐标两两不同。</p>
<p>第一个基站的有效覆盖范围 $r_1$ 和第二个基站的有效覆盖范围 $r_2$ 均可由约翰自由设定。</p>
<p>因为奶牛喜欢保持电子邮件联系，所以约翰希望所有奶牛都能被无线网络覆盖。</p>
<p>如果一头奶牛满足以下两个条件中的<strong>至少</strong>一个：</p>
<ul>
<li>它到第一个基站的距离不超过 $r_1$</li>
<li>它到第二个基站的距离不超过 $r_2$</li>
</ul>
<p>那么就视为它已被无线网络覆盖。</p>
<p>同时为了降低成本，约翰希望 ${r_1}^2+{r_2}^2$ 尽可能小。</p>
<p>请你计算 ${r_1}^2+{r_2}^2$ 的最小可能值。</p>
<h4>输入格式</h4>
<p>第一行包含 $5$ 个整数 $n,x_1,y_1,x_2,y_2$，其中 $n$ 为奶牛数量，$(x_1,y_1)$ 为第一个基站的坐标，$(x_2,y_2)$ 为第二个基站的坐标。</p>
<p>接下来 $n$ 行，每行包含两个整数 $x_i,y_i$，表示一头奶牛的位置坐标 $(x_i,y_i)$。</p>
<h4>输出格式</h4>
<p>输出 ${r_1}^2+{r_2}^2$ 的最小可能值，答案四舍五入到个位。</p>
<h4>数据范围</h4>
<p>前 $4$ 个测试点满足 $1 \le n \le 10$。<br />
所有测试点满足 $1 \le n \le 2000$，$-10^7 \le x_i,y_i \le 10^7$。</p>
<h4>输入样例1：</h4>
<pre><code>2 -1 0 5 3
0 2
5 2
</code></pre>

<h4>输出样例1：</h4>
<pre><code>6
</code></pre>

<h4>输入样例2：</h4>
<pre><code>4 0 0 5 0
9 4
8 3
-1 0
1 4
</code></pre>

<h4>输出样例2：</h4>
<pre><code>33
</code></pre>

<p>这题还是挺难想的…..朴素的想法是枚举一下r1，枚举一下r2，然后再循环一遍看是否所有点都被覆盖。这是$O(n^3)$(TLE)<br>但是我们可以发现：1、圆的边界一定是至少有一个点的(假设没有，那么我们可以缩小圆的面积而不会使得结果变差)<br>2、我们可以通过更改枚举顺序进行优化。我们<strong>从大到小</strong>枚举r1距离，“从大到小保证了，每次只会从r1覆盖的点集中一次<strong>只抛出一个点</strong>，而在r2的点集中<strong>只加入一个点</strong>”。这样我们就可以<strong>在线性的时间内完成枚举所有r1和r2的选法</strong><br>顺带一提这题不需要用堆进行优化，因为它在处理集合的最值过程中，对于一个集合只有“加入”而没有“删除”操作，所以用一个变量动态维护一下就可以了</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define x first
#define y second
const int N = 2010;
typedef pair&lt;int, int&gt; PII;
typedef long long LL;
int n;
PII s1,s2;
PII q[N];
LL get_dist(PII a,PII b)
&#123;
    LL dx = a.x - b.x,dy = a.y - b.y;
    return dx * dx + dy * dy;
&#125;
bool cmp(PII a,PII b)
&#123;
    return get_dist(a,s1) &lt; get_dist(b,s1);  
&#125;
int main()
&#123;
    cin &gt;&gt; n &gt;&gt; s1.x &gt;&gt; s1.y &gt;&gt; s2.x &gt;&gt; s2.y;
    for(int i = 0;i &lt; n;i ++) cin &gt;&gt; q[i].x &gt;&gt; q[i].y;
    
    sort(q,q + n,cmp);
    LL res = 1e18,r = 0;
    for(int i = n - 1;i &gt;= 0;i --)
    &#123;
        res = min(res,r + get_dist(q[i],s1));
        r = max(r,get_dist(q[i],s2));
    &#125;
    res = min(res,r);
    cout &lt;&lt; res;
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E6%9E%9A%E4%B8%BE/" style="color: #ffa2c4">枚举</a>
        </span>
        
    </div>
    <a href="/2022/06/05/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/05/24/%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F/">
        <h2 class="post-title">货币系统</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/5/24
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/code/content/3512573/">https://www.acwing.com/activity/content/code/content/3512573/</a></p>
<p>在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。</p>
<p>为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 </p>
<p>在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] × t[i]$ 的和为 $x$。</p>
<p>然而，在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。</p>
<p>例如在货币系统 $n=3, a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 </p>
<p>两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 </p>
<p>现在网友们打算简化一下货币系统。</p>
<p>他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。</p>
<p>他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。</p>
<h4>输入格式</h4>
<p>输入文件的第一行包含一个整数 $T$，表示数据的组数。</p>
<p>接下来按照如下格式分别给出 $T$ 组数据。 </p>
<p>每组数据的第一行包含一个正整数 $n$。</p>
<p>接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$。</p>
<h4>输出格式</h4>
<p>输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$。</p>
<h4>数据范围</h4>
<p>$1 \le n \le 100$,<br />
$1 \le a[i] \le 25000$,<br />
$1 \le T \le 20$</p>
<h4>输入样例：</h4>
<pre><code>2 
4 
3 19 10 6 
5 
11 29 13 19 17 
</code></pre>

<h4>输出样例：</h4>
<pre><code>2
5
</code></pre>

<p>本题是在寻找<strong>最大线性无关组</strong>，基本思路就是<strong>从小到大，看每一个数是否能被比较小的数线性表示</strong><br>那么对于每一个数的线性表示前的系数都会对应它的一个选法，系数可以无限大，这是一个完全背包问题</p>
<p><strong>朴素版</strong></p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 110,M = 25010;
bool f[N][M];//考虑前i个货币，凑起来的面值恰好为j
int T,n,m;//可行性背包问题
int v[N];
int main()
&#123;
    cin &gt;&gt; T;
    while(T --)
    &#123;
        cin &gt;&gt; n;
        for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; v[i];
        sort(v + 1,v + n + 1);
        memset(f, 0, sizeof f);//初始化表示所有数字还没有被线性表示
        //DP的起点是f[0][0]，如果没有初始化起点，f的矩阵是不会变的
        f[0][0] = true;
        for(int i = 1;i &lt;= n;i ++)
        &#123;
            for(int j = 0;j &lt;= v[n];j ++)//对于每一个数字，尝试进行线性表示以筛掉后面的数字，所以最大j要看到v[n]，这是一个完全背包问题。
            &#123;
                for(int k = 0;k * v[i] &lt;= j;k ++)
                &#123;
                    f[i][j] |= f[i - 1][j - k * v[i]];
                &#125;
            &#125;
        &#125;
        //构造完矩阵后看一下每一个数是否能被前面的数表示
        int res = 1;
        for(int i = 2;i &lt;= n;i ++)
        &#123;
            bool flag = false;
            int t = v[i];
            for(int row = 1;row &lt; i;row ++)//row &lt; i从第二个数开始看，第一个数一定是无法被前面的数线性表示的
            &#123;
                if(f[row][t] == true)//如果这个数字可以被前面的数表示
                &#123;
                     flag = true;
                     break;
                &#125;
            &#125;
            if(flag == false)//如果这个数不能被前面的数字线性表示，那么res ++
            &#123;
                res ++;
            &#125;
        &#125;
        printf(&quot;%d\n&quot;,res);
     &#125;
    return 0;
&#125;
</code></pre>
<p><strong>优化版</strong></p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 110,M = 25010;
bool f[M];//考虑前i个货币，凑起来的面值恰好为j
int T,n,m;//可行性背包问题
int v[N];
int main()
&#123;
    cin &gt;&gt; T;
    while(T --)
    &#123;
        cin &gt;&gt; n;
        for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; v[i];
        sort(v + 1,v + n + 1);
        memset(f, 0, sizeof f);
        f[0] = true;
        int res = 0;
        for(int i = 1;i &lt;= n;i ++)
        &#123;
            if(f[v[i]]) continue;//如果当前货币被前面的凑出来了直接continue
            res ++;//否则答案加1，即当前数字不能被前面线性表示
            for(int j = v[i];j &lt;= v[n];j ++)//对于每一个数字，尝试进行线性表示以筛掉后面的数字，所以最大j要看到v[n]，这是一个完全背包问题。
            &#123;
                f[j] |= f[j - v[i]];
            &#125;
        &#125;
        printf(&quot;%d\n&quot;,res);
    &#125;
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="color: #ff7d73">动态规划</a>
        </span>
        
    </div>
    <a href="/2022/05/24/%E8%B4%A7%E5%B8%81%E7%B3%BB%E7%BB%9F/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/05/21/%E4%B8%89%E6%9D%A1%E7%BA%BF/">
        <h2 class="post-title">三条线</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/5/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2015/">https://www.acwing.com/problem/content/2015/</a></p>
<p>农夫约翰想用他购买的新监视系统监视他的 $N$ 头奶牛。</p>
<p>第 $i$ 头奶牛位于具有整数坐标的位置 $(x_i,y_i)$。</p>
<p>没有两头奶牛占据相同的位置。</p>
<p>约翰的监视系统包含三个特殊的摄像头，每个摄像头都能够沿垂直或水平线观察一条线上所有的奶牛。</p>
<p>请确定约翰是否可以通过合理设置三个摄像头的摆放位置，以便他可以监视所有 $N$ 头奶牛。</p>
<p>也就是说，请确定是否可以通过三条垂直或水平摆放的线将所有 $N$ 个奶牛所在位置全部覆盖。</p>
<h4>输入格式</h4>
<p>第一行包含整数 $N$。</p>
<p>接下来 $N$ 行，每行包含两个整数 $x_i,y_i$，表示一头奶牛所在位置的横纵坐标。</p>
<h4>输出格式</h4>
<p>如果可以通过三条垂直或水平摆放的线将所有 $N$ 个奶牛所在位置全部覆盖，请输出 $1$，否则输出 $0$。</p>
<h4>数据范围</h4>
<p>$1 \le N \le 50000$,<br />
$0 \le x_i,y_i \le 10^9$</p>
<h4>输入样例：</h4>
<pre><code>6
1 7
0 0
1 2
2 0
1 4
3 4
</code></pre>

<h4>输出样例：</h4>
<pre><code>1
</code></pre>

<h4>样例解释</h4>
<p>$y = 0,x = 1,y = 4$ 可满足将所有奶牛位置覆盖。</p>

<p>暴力枚举思路是枚举每一条线，这样就是Cn3种情况，三层for循环复杂度立方级别(TLE)。<br>更精巧的想法是换了一个枚举思路。类似于“最小圆覆盖”问题<br>先枚举每一个点，然后每个点其实只有两种情况(被横线覆盖或者被竖线覆盖)，这样就是一个DFS问题了<br>搜索深度是三(只有三条线)，所以复杂度为O(8n)可以过</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;unordered_set&gt;
#define x first
#define y second
using namespace std;
const int N = 50010;
typedef pair&lt;int, int&gt; PII;
PII q[N];
int n;
unordered_set&lt;int&gt; row,col;
int dfs(int u,int cnt)
&#123;
    if(u == n + 1) return 1;
    if(cnt &gt; 3) return 0;
    if(row.count(q[u].y) || col.count(q[u].x)) return dfs(u + 1,cnt);//如果这个点被覆盖了直接跳过
    //如果这个点没有被覆盖过枚举两种情况：是被横线覆盖还是竖线覆盖  
    
    row.insert(q[u].y);//被横线覆盖，选定了当前直线加入集合中
    if(dfs(u + 1,cnt + 1)) return 1;//多了一条直线，如果有解的话就return 1
    row.erase(q[u].y);//恢复现场
    
    col.insert(q[u].x);
    if(dfs(u + 1,cnt + 1)) return 1;
    col.erase(q[u].x);
    
    return 0;
&#125;

int main()
&#123;
    cin &gt;&gt; n;
    for(int i = 1;i &lt;= n;i ++)
    &#123;
        int a,b;
        cin &gt;&gt; a &gt;&gt; b;
        q[i] = &#123;a,b&#125;;
    &#125;
    printf(&quot;%d&quot;,dfs(1,0));
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E6%80%9D%E7%BB%B4%E9%A2%98/" style="color: #ff7d73">思维题</a>
        </span>
        
    </div>
    <a href="/2022/05/21/%E4%B8%89%E6%9D%A1%E7%BA%BF/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/05/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%82%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/">
        <h2 class="post-title">背包问题求具体方案</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E7%AE%97%E6%B3%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                算法
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/5/18
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
             <p>有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。</p>
<p>第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。</p>
<p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。</p>
<p>输出 <strong>字典序最小的方案</strong>。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1 &hellip; N$。</p>
<h4>输入格式</h4>
<p>第一行两个整数，$N，V$，用空格隔开，分别表示物品数量和背包容积。</p>
<p>接下来有 $N$ 行，每行两个整数 $v_i, w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。</p>
<h4>输出格式</h4>
<p>输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。</p>
<p>物品编号范围是 $1 &hellip; N$。</p>
<h4>数据范围</h4>
<p>$0 \lt N, V \le 1000$<br />
$0\lt v_i, w_i \le 1000$</p>
<h4>输入样例</h4>
<pre><code>4 5
1 2
2 4
3 4
4 6
</code></pre>

<h4>输出样例：</h4>
<pre><code>1 4
</code></pre>

<p><strong>本题是求具体方案，求方案的思路根据图的转移过程从后往前倒推一遍，看一下每一个状态由哪一个状态转移而来</strong><br>如图所示:<br><img src="https://cdn.acwing.com/media/article/image/2022/05/18/142088_efcc3465d6-%E8%83%8C%E5%8C%85%E5%80%92%E6%8E%A8%E6%B1%82%E6%96%B9%E6%A1%88.png" alt="背包倒推求方案.png"><br>看<strong>f[i][j]与f[i - 1][j]和f[i - 1][j - v[i]] + w[i]在数值上与哪一个相等</strong>，从而决定是由哪一个转移过来，从而判断第i个物品选没选<br>但是本题要求字典序输出，那么我们使用贪心的思想。<strong>从前往后对于任意一个物品x，有三种选择S : {(只能选,必选)，(只能不选，必不选),(可选可不选，一定要选)}</strong><br>一个朴素的想法就是我们<strong>先从后往前进行物品的决策</strong>，然后这样的“倒推”就是从前往后的正序了。(体现在图上就是边的方向要改变一下)</p>
<pre><code class="C++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 1010;
int v[N],w[N];
int f[N][N];
int n,m;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];
    
    for(int i = n;i &gt;= 1;i --)//从后往前进行决策
    &#123;
        for(int j = 0;j &lt;= m;j ++)
        &#123;
            f[i][j] = f[i + 1][j];
            if(j &gt;= v[i]) f[i][j] = max(f[i][j],f[i + 1][j - v[i]] + w[i]);
        &#125;
    &#125;
    int t = m;
    for(int i = 1;i &lt;= n;i ++)//求具体方案是一个图上的倒推的过程
    &#123;
        if(t &gt;= v[i] &amp;&amp; f[i][t] == f[i + 1][t - v[i]] + w[i])//如果能转移过来并且选了这个物品的话
        &#123;
            printf(&quot;%d &quot;,i);
            t -= v[i];//选完这个物品后剩下的背包体积
        &#125;
    &#125;
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="color: #ff7d73">动态规划</a>
        </span>
        
    </div>
    <a href="/2022/05/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%82%E5%85%B7%E4%BD%93%E6%96%B9%E6%A1%88/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    <div class="prev">
        
        <a class="page-num" href="/page/2/">
            <i class="fa-solid fa-caret-left fa-fw"></i>
        </a>
        
    </div>
    <div class="page-index">
        
        <span>
            
            
            
            <a class="page-num" href="/">1</a>
            
            
            
            <a class="page-num" href="/page/2/">2</a>
        </span>
        
        <span class="current">3</span>
        
        <span>
            <a class="page-num" href="/page/4/">4</a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a class="page-num" href="/page/4/">
            <i class="fa-solid fa-caret-right fa-fw"></i>
        </a>
        
    </div>
</div>

    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">金冠小熊猫</div>
        <div class="description">
            <p>Emailme:<a href="mailto:&#x31;&#x37;&#x35;&#x32;&#x35;&#x31;&#56;&#x38;&#56;&#x30;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#x31;&#x37;&#x35;&#x32;&#x35;&#x31;&#56;&#x38;&#56;&#x30;&#x40;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a><br>…</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 GoldenPanda&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;金冠小熊猫
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

                </div>
            </transition>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
    </body>
</html>
