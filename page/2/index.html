
<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8" />
        <title>金冠小熊猫</title>
        <meta name="author" content="金冠小熊猫" />
        <meta name="description" content="温故而知新" />
        <meta name="keywords" content="菜狗大学生" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/favicon.png" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>金冠小熊猫</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;金冠小熊猫</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>金冠小熊猫</h1>
                <h3>金冠小熊猫</h3>
                <h5>温故而知新</h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap"  ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/2022/11/19/1%E7%9A%84%E4%B8%AA%E6%95%B0/">
        <h2 class="post-title">1的个数</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>一道经典习题<br>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1535/">https://www.acwing.com/problem/content/1535/</a></p>
<p>给定一个数字 $N$，请你计算 $1 \sim N$ 中一共出现了多少个数字 $1$。</p>
<p>例如，$N = 12$ 时，一共出现了 $5$ 个数字 $1$，分别出现在 $1,10,11,12$ 中。</p>
<h4>输入格式</h4>
<p>包含一个整数 $N$。</p>
<h4>输出格式</h4>
<p>输出一个整数，表示 $1$ 的个数。</p>
<h4>数据范围</h4>
<p>$1 \le N \le 2^{30}$</p>
<h4>输入样例：</h4>
<pre><code>12
</code></pre>

<h4>输出样例：</h4>
<pre><code>5
</code></pre>

<pre><code>/*
基本思路是看一下数字1在每一个数位会出现多少次
讨论数字：abcdefg(其中每一个字母代表给出的每一个数位上的数字)
做的过程是从前到后看一下给定的n的每一个数位，讨论该数位d &lt; 1?(即d=0,每个数位必是0~9) d = 1? d &gt; 1?
    1.如果d &lt; 1,即给定数字n的该数位为0，那么在这个位置上，《在保证数值不超过n》还能出现1的情况是：（先考虑高位）
        高位为000~abc-1，低位就随便取000~999
    2.如果d = 1,即给定数字n的该数位为1，如果想保证数值不超过n该数位还能是1的话：
        高位就要取000~abc-1,此时低位取000~999随便取，高位要取abc的话，低位只能取000~efg;
    3.如果d &gt; 1，如果想保证数值不超过n，且该数位还能是1的话：
        高位取000~abc，（注意不能取到abc更多了，因为比大小从高位开始看起，不应该让高位的数字超过给定的n高位）
        在保证了高位一定小于n的情况下，低位000~999随便取
三种情况，利用计数原理(中的乘法原理)，计算，求得数量。
*/
</code></pre>
<hr>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
int n;
int cal(int x)
&#123;
    vector&lt;int&gt; nums;
    while(x) nums.push_back(x % 10),x /= 10;//这里先存的是低位
    int sum = 0;
    for(int i = nums.size() - 1;i &gt;= 0;i --)//从高位往低位看
    &#123;
        int d = nums[i]; //取出这个数位
        int left = 0,right = 0,power = 1;
        for(int j = nums.size() - 1;j &gt; i;j --) left = left * 10 + nums[j];//抠出来每一个数位连续起来的值都要统一从高位开始做起
        for(int j = i - 1;j &gt;= 0;j --) right = right * 10 + nums[j],power *= 10;
        
        if(d == 0) sum += left * power;
        else if(d == 1) sum += left * power + right + 1;//000~efg一共right + 1个数
        else sum += (left + 1) * power;
    &#125;
    return sum;
&#125;
int main()
&#123;
    cin &gt;&gt; n;
    int res = cal(n);
    cout &lt;&lt; res;
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E6%95%B0%E5%AD%A6/" style="color: #ff7d73">数学</a>
        </span>
        
    </div>
    <a href="/2022/11/19/1%E7%9A%84%E4%B8%AA%E6%95%B0/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/11/19/Dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/">
        <h2 class="post-title">Dijkstra求最短路</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
             <p>给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p>
<p>请你求出 $1$ 号点到 $n$ 号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 $-1$。</p>
<h4>输入格式</h4>
<p>第一行包含整数 $n$ 和 $m$。</p>
<p>接下来 $m$ 行每行包含三个整数 $x,y,z$，表示存在一条从点 $x$ 到点 $y$ 的有向边，边长为 $z$。</p>
<h4>输出格式</h4>
<p>输出一个整数，表示 $1$ 号点到 $n$ 号点的最短距离。</p>
<p>如果路径不存在，则输出 $-1$。</p>
<h4>数据范围</h4>
<p>$1 \le n \le 500$,<br />
$1 \le m \le 10^5$,<br />
图中涉及边长均不超过10000。</p>
<h4>输入样例：</h4>
<pre><code>3 3
1 2 2
2 3 1
1 3 4
</code></pre>

<h4>输出样例：</h4>
<pre><code>3
</code></pre>

<p>DFS暴力求最短路。如果加上一个Depth参数，可以限制深度。<br>DFS求最短路是在遍历到每一个点的时候做更新。而dijkstra求最短路，是在扩展每个点的时候做。两者的流程有些不同<br>不过核心思想都是一样的，<strong>只要一个点被多次更新的时候，遇到更小的，就去更新它。</strong><br>如题目：<a href="https://">https://www.acwing.com/file_system&#x2F;file&#x2F;content&#x2F;whole&#x2F;index&#x2F;content&#x2F;7299482&#x2F;</a><br><strong>在遍历每个点的时候做：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 510,M = 100010;
int g[N][N];
int n,m;
int dist[N];
bool st[N];
void dfs(int u,int curlen)
&#123;
    //cout &lt;&lt; u &lt;&lt; endl;
    if(dist[u] &lt;= curlen) return;
    if(u == n)
    &#123;
        if(dist[n] &gt; curlen) dist[n] = curlen;
    &#125;
    else
    &#123;
        if(dist[u] &gt; curlen) dist[u] = curlen;
        for(int i = 1;i &lt;= n;i ++)
        &#123;
            if(g[u][i] != 0x3f3f3f3f) dfs(i,curlen + g[u][i]);
        &#125;
    &#125;
    return;
&#125;

int main()
&#123;
    memset(dist,0x3f,sizeof dist);
    memset(g,0x3f,sizeof g);
    cin &gt;&gt; n &gt;&gt; m;
    while(m --)
    &#123;
        int a,b,c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        g[a][b] = min(g[a][b],c);
    &#125;
    dfs(1,0);
    if(dist[n] == 0x3f3f3f3f) printf(&quot;-1&quot;);
    else cout &lt;&lt; dist[n];
    return 0;
&#125;
</code></pre>
<hr>
<p><strong>在扩展的时候做：</strong></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 510;
int n,m;
int g[N][N],d[N];
bool st[N];
int dijkstra()
&#123;
    memset(d,0x3f,sizeof d);
    d[1] = 0;
    for(int i = 0;i &lt; n - 1;i ++)
    &#123;
        int t = -1;
        for(int j = 1;j &lt;= n;j ++)
        &#123;
            if(!st[j] &amp;&amp; (t == -1 || d[t] &gt; d[j]))
            &#123;
                t = j;
            &#125;
        &#125;
        st[t] = true;
        for(int j = 1;j &lt;= n;j ++)
        &#123;
            if(d[j] &gt; d[t])
            &#123;
                d[j] = min(d[j],d[t] + g[t][j]);
            &#125;
        &#125;
    &#125;
    if (d[n] == 0x3f3f3f3f) return -1;
    return d[n];
&#125;

int main()
&#123;
    memset(g,0x3f,sizeof g);
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    while(m --)
    &#123;
        int a,b,w;
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);
        g[a][b] = min(g[a][b],w);
    &#125;
    int res = dijkstra();
    printf(&quot;%d&quot;,res);
    return 0;
&#125;
</code></pre>
<p>在扩展更新的模式下，为了保证扩展的正确性，都会先把“起点”处理一下。而直接对那个点做dfs，就事先不需要做什么处理，因为我们会在递归的每个点里去做。这是两种流程的特点</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="color: #03a9f4">图论</a>
        </span>
        
    </div>
    <a href="/2022/11/19/Dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/11/19/%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91/">
        <h2 class="post-title">微博转发</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1564/">https://www.acwing.com/problem/content/1564/</a></p>
<p>微博被称为中文版的 Twitter。 </p>
<p>微博上的用户既可能有很多关注者，也可能关注很多其他用户。 </p>
<p>因此，形成了一种基于这些关注关系的社交网络。 </p>
<p>当用户在微博上发布帖子时，他/她的所有关注者都可以查看并转发他/她的帖子，然后这些人的关注者可以对内容再次转发&hellip;</p>
<p>现在给定一个社交网络，假设只考虑 $L$ 层关注者，请你计算某些用户的帖子的最大可能转发量。</p>
<h4>补充</h4>
<p>如果 $B$ 是 $A$ 的关注者，$C$ 是 $B$ 的关注者，那么 $A$ 的第一层关注者是 $B$，第二层关注者是 $C$。</p>
<h4>输入格式</h4>
<p>第一行包含两个整数，$N$ 表示用户数量，$L$ 表示需要考虑的关注者的层数。</p>
<p>假设，所有的用户的编号为 $1 \sim N$。</p>
<p>接下来 $N$ 行，每行包含一个用户的关注信息，格式如下：</p>
<pre><code>M[i] user_list[i]
</code></pre>

<p><code>M[i]</code> 是第 $i$ 名用户关注的总人数，<code>user_list[i]</code> 是第 $i$ 名用户关注的 <code>M[i]</code> 个用户的编号列表。</p>
<p>最后一行首先包含一个整数 $K$，表示询问次数，然后包含 $K$ 个用户编号，表示询问这些人的帖子的最大可能转发量。</p>
<h4>输出格式</h4>
<p>按顺序，每行输出一个被询问人的帖子最大可能转发量。</p>
<p>假设每名用户初次看到帖子时，都会转发帖子，只考虑 $L$ 层关注者。</p>
<h4>数据范围</h4>
<p>$1 \le N \le 1000$,<br />
$1 \le L \le 6$,<br />
$1 \le M[i] \le 100$,<br />
$1 \le K \le N$</p>
<h4>输入样例：</h4>
<pre><code>7 3
3 2 3 4
0
2 5 6
2 3 1
2 3 4
1 4
1 5
2 2 6
</code></pre>

<h4>输出样例：</h4>
<pre><code>4
5
</code></pre>

<p><img src="https://cdn.acwing.com/media/article/image/2022/11/19/142088_dfadffd167-QQ%E5%9B%BE%E7%89%8720221119152150.png" alt="QQ图片20221119152150.png"><br>这道题就可以深刻体会到，BFS能够直接求边权为1的最短路的好处了。<br>这道题也要走最短的一条路，怪不得DFS半天过不去，在DFS的过程当中还要<strong>维护一个每个点的最短路径</strong><br>当然，最好直接用BFS做就行了….</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;
const int N = 1010;
vector&lt;int&gt; g[N];
int n,depth;
bool st[N];
int cnt;
int dist[N];
void dfs(int u,int curlen) 
&#123;
    if(curlen &gt;= dist[u]) return;
    if(curlen &gt; depth) return;
    dist[u] = curlen;
    for(auto j : g[u])
    &#123;
        dfs(j,curlen + 1);
    &#125;
    return;
&#125;

int main()
&#123;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;depth);
    int num,b;
    for(int i = 1;i &lt;= n;i ++)
    &#123;
        scanf(&quot;%d&quot;,&amp;num);
        while(num --)
        &#123;
            scanf(&quot;%d&quot;,&amp;b);
            g[b].push_back(i);
        &#125;
    &#125;
    int k,id;
    scanf(&quot;%d&quot;,&amp;k);
    while(k --)
    &#123;
        scanf(&quot;%d&quot;,&amp;id);
        cnt = 0;
        //cout &lt;&lt; id &lt;&lt; endl;
        memset(st,0,sizeof st);
        memset(dist,0x3f,sizeof dist);
        dfs(id,0);
        for(int i = 1;i &lt;= n;i ++)
            if(dist[i] != 0x3f3f3f3f) cnt ++;
        printf(&quot;%d\n&quot;,cnt - 1);
    &#125;
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="color: #ffa2c4">图论</a>
        </span>
        
    </div>
    <a href="/2022/11/19/%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/11/19/%E5%8A%A0%E6%B2%B9%E7%AB%99/">
        <h2 class="post-title">加油站</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/19
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1560/">https://www.acwing.com/problem/content/1560/</a><br> <p>加油站的建造位置必须使加油站与距离它最近的房屋的距离尽可能远。 </p></p>
<p>与此同时，它还必须保证所有房屋都在其服务范围内。</p>
<p>现在，给出了城市地图和加油站的几个候选位置，请你提供最佳建议。 </p>
<p>如果有多个解决方案，请输出选取位置与所有房屋的平均距离最小的解决方案。 </p>
<p>如果这样的解决方案仍然不是唯一的，请输出选取位置编号最小的解决方案。</p>
<h4>输入格式</h4>
<p>第一行包含四个整数 $N$，房屋总数，$M$，加油站的候选位置总数，$K$，连接房屋或加油站的道路总数，$D_s$ 加油站的最大服务范围。</p>
<p>所有房屋的编号从 $1$ 到 $N$，所有加油站侯选位置编号从 <code>G1</code> 到 <code>GM</code>。</p>
<p>接下来 $K$ 行，每行格式如下：</p>
<pre><code>P1 P2 Dist
</code></pre>

<p>其中，<code>P1</code> 和 <code>P2</code> 表示一条 <strong>无向</strong> 道路连接的两个房屋或加油站侯选位置的编号，<code>Dist</code> 是道路长度，这是一个整数。</p>
<h4>输出格式</h4>
<p>第一行输出所选位置的编号。</p>
<p>第二行输出加油站与距离其最近的房屋之间的距离以及与所有房屋之间的平均距离，<strong>精确到小数后一位</strong>。</p>
<p>如果解决方案不存在，则输出 <code>No Solution</code>。</p>
<h4>数据范围</h4>
<p>$1 \le N \le 10^3$,<br />
$1 \le M \le 10$,<br />
$1 \le K \le 10^4$,<br />
$1 \le D_s \le 200$,<br />
$1 \le Dist \le 5000$</p>
<h4>输入样例1：</h4>
<pre><code>4 3 11 5
1 2 2
1 4 2
1 G1 4
1 G2 3
2 3 2
2 G2 1
3 4 2
3 G3 2
4 G1 3
G2 G1 1
G3 G2 2
</code></pre>

<h4>输出样例1：</h4>
<pre><code>G1
2.0 3.3
</code></pre>

<h4>输入样例2：</h4>
<pre><code>2 1 2 10
1 G1 9
2 G1 20
</code></pre>

<h4>输出样例2：</h4>
<pre><code>No Solution
</code></pre>

<pre><code>/*
本来我的设计是想让函数返回很多值的，一个距离，一个总和，一个是否合法(这样就要搞一个结构体存，有些麻烦)
然后发现其实“可以把多个参数传引用进去”，以达到同样的效果。
printf(&quot;%.1lf %.1lf&quot;,(double)maxD,(double)sumD / n + 1e-8);
(double)sumD / n是：《先》把类型映射成double,然后《再》进行除法运算。
如果你不转成double就去除法运算，再以.1lf输出的话，显示的就是0.0了
之所以要加上1e-8，是因为如果检查double 以.10lf输出，当显示是3.2500000000时，此时以答案格式.1lf输出是3.2
理论上应该四舍五入的，为什么是3.2呢？原因就是虽然操作系统给你显示的是3.25,但它实际上内部存储的是3.24999999....
所以当只保留一位小数的时候是3.24999999去四舍成了3.2，为了解决这种情况要加一个很小的1e-8使得内部存储真正变成3.25,
然后让操作系统输出显示成3.3;

printf(&quot;%d\n&quot;,3.24999999 / 3);   -----&gt;2147483640
printf(&quot;%lf\n&quot;,3.24999999 / 3);  ------&gt; 1.083333
格式化输出的时候，不给予正确的格式，在读的时候是无法正确译码的
---------------------------------------
        printf(&quot;%d\n&quot;,3.24999999 / 3);
        printf(&quot;%d\n&quot;,13 / 3);
        printf(&quot;%f\n&quot;,13 / 3);
输出：22460624
      4
      1.083333
-----------------------------------------
如果只写   printf(&quot;%f\n&quot;,13 / 3);
输出：    0.000000
如果前面加上 printf(&quot;%d\n&quot;,3.24999999 / 3); 再printf(&quot;%f\n&quot;,13 / 3);
输出：  22460624
        1.083333
*/
</code></pre>
<p>关于输出的问题解答：<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/447078607/answer/1759629334">https://www.zhihu.com/question/447078607/answer/1759629334</a><br>根据 c printf 的文档：<strong>If a conversion specification is invalid, the behavior is undefined.</strong><br>所以这种代码的行为完全取决于编译器的实现，发生什么都不奇怪。做实验测试 c&#x2F;cpp 的行为是完全不可靠的，因为 c&#x2F;cpp 的 UB 实在太多了。拿实验结果&#x2F;汇编代码来倒推语言标准更是本末倒置。遇到问题最好还是查文档，实验仅用于验证。</p>
<p>作者：lljbash<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/447078607/answer/1759667992">https://www.zhihu.com/question/447078607/answer/1759667992</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 2010,INF = 0x3f3f3f3f;
typedef pair&lt;int,int&gt; PII;
int n,m,k,D;
int g[N][N];
int get_num(string s)
&#123;
    if(s[0] == &#39;G&#39;) return stoi(s.substr(1)) + n;
    return stoi(s);
&#125;
int dist[N];
bool st[N];
bool dijkstra(int S,int&amp; maxD,int&amp; sumD,int&amp; minID)
&#123;
    memset(st,0,sizeof st);
    memset(dist,0x3f,sizeof dist);
    dist[S] = 0;
    for(int i = 1;i &lt;= n + m;i ++)
    &#123;
        int t = -1;
        for(int j = 1;j &lt;= n + m;j ++)
        &#123;
            if(!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))
            &#123;
                t = j;
            &#125;
        &#125;
        st[t] = true;
        for(int j = 1;j &lt;= n + m;j ++)
            dist[j] = min(dist[j],dist[t] + g[t][j]);
    &#125;
    int sum = 0,mindist = INF;
    for(int i = 1;i &lt;= n;i ++)
    &#123;
        if(dist[i] &gt; D) return false;
        sum += dist[i];
        mindist = min(mindist,dist[i]);
    &#125;
    if(mindist &gt; maxD)
    &#123;
        maxD = mindist;
        sumD = sum;
        minID = S;
    &#125;
    else if(mindist == maxD)
    &#123;
        if(sum &lt; sumD)
        &#123;
            sumD = sum;
            minID = S;
        &#125;
        else if(sum == sumD)
        &#123;
            if(minID &gt; S) minID = S;
        &#125;
    &#125;
    return true;
&#125;
int main()
&#123;
    memset(g,0x3f,sizeof g);    
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; D;
    string a,b;
    int w;
    while(k --)
    &#123;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
        int x = get_num(a),y = get_num(b);
        //cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; &#39; &#39; &lt;&lt; w &lt;&lt; endl;
        g[x][y] = g[y][x] = min(g[x][y],w);
    &#125;
    int maxD = 0,sumD = INF,minID = INF;
    for(int i = n + 1;i &lt;= n + m;i ++)
    &#123;
        bool is_valid = dijkstra(i,maxD,sumD,minID);//本来我的设计是想让函数返回很多值的，一个距离，一个总和，一个是否合法
        if(!is_valid) continue;//然后发现其实“可以把多个参数传引用进去”，以达到同样的效果。
    &#125;
    if(minID != INF)
    &#123;
        //cout &lt;&lt; minID &lt;&lt; &#39; &#39; &lt;&lt; maxD &lt;&lt; &#39; &#39; &lt;&lt; sumD &lt;&lt; endl;
        printf(&quot;G%d\n&quot;,minID - n);
        printf(&quot;%.1lf %.1lf&quot;,(double)maxD,(double)sumD / n + 1e-8);
    &#125;
    else printf(&quot;No Solution&quot;);
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="color: #00a596">图论</a>
        </span>
        
    </div>
    <a href="/2022/11/19/%E5%8A%A0%E6%B2%B9%E7%AB%99/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/11/15/%E7%B4%A7%E6%80%A5%E6%83%85%E5%86%B5/">
        <h2 class="post-title">紧急情况</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/15
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1477/">https://www.acwing.com/problem/content/1477/</a></p>
 <p>作为城市的紧急救援团队负责人，你将获得一张你所在国家的特殊地图。</p>
<p>该地图显示了一些通过道路连接的分散城市，<strong>道路是双向的</strong>。</p>
<p>地图上标出了每个城市的救援队数量以及每对城市之间的每条道路的长度。</p>
<p>当其他城市发出紧急求援信息时，你的工作是尽快带领你的士兵前往该地点，同时，在途中尽可能多地调动救援帮手。</p>
<h4>输入格式</h4>
<p>第一行包含四个整数 $N$，表示城市数量（城市编号从 $0$ 到 $N-1$），$M$ 表示道路数量，$C_1$ 表示你当前所在的城市编号，$C_2$ 表示发出紧急求援信息的城市编号。</p>
<p>第二行包含 $N$ 个整数，其中第 $i$ 个整数表示城市 $i$ 的救援队数量。</p>
<p>接下来 $M$ 行，每行包含三个整数 $c_1,c_2,L_i$，表示城市 $c_1$ 和城市 $c_2$ 之间存在一条道路相连，道路长度为 $L_i$。</p>
<p>数据保证 $C_1$ 和 $C_2$ 之间至少存在一条路径相连。</p>
<h4>输出格式</h4>
<p>共一行，两个整数，第一个整数表示 $C_1$ 和 $C_2$ 之间最短路的数量，第二个整数表示走最短路的情况下，能聚集到的救援队最大数量。</p>
<h4>数据范围</h4>
<p>$2 \le N \le 500$,<br />
$1 \le M \le 600$,<br />
$1 \le L_i \le 200$,<br />
每个城市包含的救援人员数量不超过 $200$。</p>
<h4>输入样例：</h4>
<pre><code>5 6 0 2
1 2 1 5 3
0 1 1
0 2 2
0 3 1
1 2 1
2 4 1
3 4 1
</code></pre>

<h4>输出样例：</h4>
<pre><code>2 4
</code></pre>

<p><img src="https://cdn.acwing.com/media/article/image/2022/11/15/142088_fcb4b3af64-QQ%E5%9B%BE%E7%89%8720221115152721.png" alt="QQ图片20221115152721.png"><br>对于一个点，可能会被多次更新</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 610;
int n,m,S,T;
int g[N][N],w[N];
int dist[N],cnt[N],sum[N];
bool st[N];
void dijkstra()
&#123;
    memset(dist,0x3f,sizeof dist);
    dist[S] = 0,cnt[S] = 1,sum[S] = w[S];
    for(int i = 0;i &lt; n;i ++)
    &#123;
        int t = -1;
        for(int j = 0;j &lt; n; j ++)
        &#123;
            if(!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))
            &#123;
                t = j;
            &#125;
        &#125;
        //cout &lt;&lt; t &lt;&lt; endl;
        st[t] = true;
        for(int j = 0;j &lt; n; j ++)
        &#123;
            if(dist[j] &gt; dist[t] + g[t][j])//当最短路径被更新的时候
            &#123;
                dist[j] = dist[t] + g[t][j];
                cnt[j] = cnt[t];
                sum[j] = sum[t] + w[j];
            &#125;
            else if(dist[j] == dist[t] + g[t][j])//如果有等长的最短路径
            &#123;
                cnt[j] += cnt[t];
                sum[j] = max(sum[j],sum[t] + w[j]);
            &#125;
        &#125;
    &#125;
&#125;
int main()
&#123;
    memset(g,0x3f,sizeof g);
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; S &gt;&gt; T;
    for(int i = 0;i &lt; n; i ++) cin &gt;&gt; w[i];
    while(m --)
    &#123;
        int a,b,c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        g[a][b] = g[b][a] = min(g[a][b],c);
    &#125;
    dijkstra();
    printf(&quot;%d %d&quot;,cnt[T],sum[T]);
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="color: #00bcd4">图论</a>
        </span>
        
    </div>
    <a href="/2022/11/15/%E7%B4%A7%E6%80%A5%E6%83%85%E5%86%B5/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/11/09/AVL%E6%A0%91%E7%9A%84%E6%A0%B9/">
        <h2 class="post-title">AVL树的根</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/9
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1554/">https://www.acwing.com/problem/content/1554/</a></p>
<p>AVL树是一种自平衡二叉搜索树。 </p>
<p>在AVL树中，任何节点的两个子树的高度最多相差 $1$ 个。 </p>
<p>如果某个时间，某节点的两个子树之间的高度差超过 $1$，则将通过树旋转进行重新平衡以恢复此属性。 </p>
<p>图 $1-4$ 说明了旋转规则。</p>
<p><img alt="31.jpg" src="https://cdn.acwing.com/media/article/image/2020/03/30/19_3a941ca472-31.jpg" /> <img alt="32.jpg" src="https://cdn.acwing.com/media/article/image/2020/03/30/19_3dd0488472-32.jpg" /> <br />
<img alt="33.jpg" src="https://cdn.acwing.com/media/article/image/2020/03/30/19_411c0b5472-33.jpg" /> <img alt="34.jpg" src="https://cdn.acwing.com/media/article/image/2020/03/30/19_43ea12f472-34.jpg" /> </p>
<p>现在，给定插入序列，请你求出 AVL 树的根是多少。</p>
<h4>输入格式</h4>
<p>第一行包含整数 $N$，表示总插入值数量。</p>
<p>第二行包含 $N$ 个不同的整数，表示每个插入值。</p>
<h4>输出格式</h4>
<p>输出得到的 AVL 树的根是多少。</p>
<h4>数据范围</h4>
<p>$1 \le N \le 20$</p>
<h4>输入样例1：</h4>
<pre><code>5
88 70 61 96 120
</code></pre>

<h4>输出样例1：</h4>
<pre><code>70
</code></pre>

<h4>输入样例2：</h4>
<pre><code>7
88 70 61 96 120 90 65
</code></pre>

<h4>输出样例2：</h4>
<pre><code>88
</code></pre>

<p><img src="https://cdn.acwing.com/media/article/image/2022/11/09/142088_3e4c480d60-AVL.png" alt="AVL.png"> </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 30;
int tr[N],h[N],l[N],r[N],idx;
int n;
void pushup(int u)
&#123;
    h[u] = max(h[l[u]],h[r[u]]) + 1;
&#125;
void R(int&amp; u)
&#123;
    int p = l[u];
    l[u] = r[p],r[p] = u;
    pushup(u),pushup(p);
    u = p;//更新根节点
&#125;
void L(int&amp; u)
&#123;
    int p = r[u];
    r[u] = l[p],l[p] = u;
    pushup(u),pushup(p);
    u = p;
&#125;
int get_balance(int u)
&#123;
    return h[l[u]] - h[r[u]];
&#125;
void insert(int&amp; u,int v)
&#123;
    if(!u) u = ++ idx,tr[u] = v;
    else if (v &lt; tr[u])
    &#123;
        insert(l[u],v);
        if(get_balance(u) == 2)//如果左子树比右子树高
        &#123;
            if(get_balance(l[u]) == 1) R(u);//如果左子树的左子树更高，就右旋根节点A
            else L(l[u]),R(u);//否则先左旋下面一层的左儿子B，再右旋根节点A
            //这里旋转完之后因为我们传的是引用，所以就自动把更改过的根节点传给了外部的root
        &#125;
    &#125;
    else
    &#123;
        insert(r[u],v);
        if(get_balance(u) == -2)
        &#123;
            if(get_balance(r[u]) == -1) L(u);//直接左旋根节点
            else R(r[u]),L(u);
        &#125;
    &#125;
    pushup(u);//当前树插入完成后，更新一下树高，这是一个递归的定义
&#125;
int main()
&#123;
    cin &gt;&gt; n;
    int w;
    int root = 0;
    for(int i = 0;i &lt; n;i ++)
    &#123;
        cin &gt;&gt; w;
        insert(root,w);//我们在定义函数的时候传root的引用，这样计算完后函数外的root也会改变
    &#125;//对于参数表里的参数需要发生改变的函数，我们就传进来一个引用
    cout &lt;&lt; tr[root];
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="color: #ffa2c4">数据结构</a>
        </span>
        
    </div>
    <a href="/2022/11/09/AVL%E6%A0%91%E7%9A%84%E6%A0%B9/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/11/05/%E6%8F%92%E5%85%A5%E8%BF%98%E6%98%AF%E5%A0%86%E6%8E%92%E5%BA%8F/">
        <h2 class="post-title">插入还是堆排序</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/11/5
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1590/">https://www.acwing.com/problem/content/1590/</a><br> <p>根据维基百科：</p></p>
<p>插入排序迭代，每次将一个插入元素插入到排好序的输出序列中，每次迭代插入排序都会从输入数据中移除一个元素，并在已排好序的序列中找到它所属的位置，然后将其插入。直到没有输入元素剩余为止。</p>
<p>堆排序将其输入分为已排序和未排序两个区域，并通过提取未排序区域中的最大元素并将其移至已排序的区域来迭代地缩小未排序的区域。它通过使用堆数据结构而非线性时间搜索来找到最大值。</p>
<p>现在，给定初始序列，以及经过某种排序方法多次迭代后的序列，请你判断我们使用的哪一种排序方法。</p>
<h4>注意</h4>
<p>本题题目描述中曾提到保证答案唯一。</p>
<p>不应该出现诸如下列的样例情况：</p>
<pre><code>9
3 1 2 8 7 9 4 6 0
1 2 3 7 8 9 4 6 0
</code></pre>

<p>这种样例情况，无法确定插入排序进行到了第五项还是第六项。</p>
<p>在本网站提供的数据中，并不涉及这种情况。</p>
<p>但是 PAT 官网给出了类似样例，因而可能会出现一些代码在本网站能够 AC，但在 PAT 官网 WA 的情况，特此加以声明。</p>
<h4>输入格式</h4>
<p>第一行包含整数 $N$，表示序列中整数个数。</p>
<p>第二行包含 $N$ 个整数表示初始序列。</p>
<p>第三行包含 $N$ 个整数表示经过若干次迭代后的序列。</p>
<p>假定排序的目标序列总是递增的。</p>
<h4>输出格式</h4>
<p>第一行输出 <code>Insertion Sort</code> 或 <code>Heap Sort</code>，以指明所采用的具体排序方法。</p>
<p>运用此方法再进行一次迭代，并在第二行输出本次迭代后的序列。</p>
<p>数据保证答案唯一。</p>
<h4>数据范围</h4>
<p>$1 \le N \le 100$</p>
<h4>输入样例1：</h4>
<pre><code>10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
</code></pre>

<h4>输出样例1：</h4>
<pre><code>Insertion Sort
1 2 3 5 7 8 9 4 6 0
</code></pre>

<h4>输入样例2：</h4>
<pre><code>10
3 1 2 8 7 5 9 4 6 0
6 4 5 1 0 3 2 7 8 9
</code></pre>

<h4>输出样例2：</h4>
<pre><code>Heap Sort
5 4 3 1 0 2 6 7 8 9
</code></pre>

<p>复习一下堆排序，堆是一个递归定义的结构<strong>：父亲节点是整颗子树的最值</strong>。这样，对于根节点来说，根节点的左右儿子是左右子树的最值，而<strong>根节点又是{左儿子、右儿子、根节点}之中的最值</strong>，所以<strong>根节点是整颗树的最值</strong>。<br>存储的时候用一个<strong>一维数组</strong>就可以存储<strong>一个完全二叉树</strong>。<br>初始化堆的时候当然一个一个插入也是可以的这是nlogn的，但是有o(n)的建堆方式，即：从n &#x2F; 2的位置一步步down到1；<br>在用一维数组维护堆的时候，通常要维护一个<strong>int size;<strong>方便O(1)插入，快速删除。<br>在</strong>删除</strong>的时候用heap[size]的元素“覆盖掉”h[1]就好了，然后<strong>down()<strong>一遍</strong>(看似是删除，实际是“覆盖”，达到删除的效果，而且用末尾元素也是我们维护size的原因)</strong><br>在<strong>插入</strong>的时候直接插入到h[size];然后**up()**一遍</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 110;
int a[N],b[N],n;
void down(int u,int size)
&#123;
    int t = u;
    if(b[u * 2] &gt; b[t] &amp;&amp; u * 2 &lt;= size) t = u * 2;
    if(b[u * 2 + 1] &gt; b[t] &amp;&amp; u * 2 + 1 &lt;= size) t = u * 2 + 1;
    if(t != u)
    &#123;
        swap(b[t],b[u]);
        down(t,size);
    &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n;
    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; a[i];
    for(int i = 1;i &lt;= n;i ++) cin &gt;&gt; b[i];
    
    int pos = 1;
    while(pos + 1 &lt;= n &amp;&amp; b[pos] &lt;= b[pos + 1]) pos ++;
    pos ++;
    bool is_insert = true;
    for(int i = pos;i &lt;= n;i ++)
    &#123;
        if(a[i] != b[i]) &#123;is_insert = false;break;&#125;
    &#125;
    if(is_insert)
    &#123;
        puts(&quot;Insertion Sort&quot;);
        int i = pos;
        while(i &gt; 1 &amp;&amp; b[i] &lt;= b[i - 1]) &#123;swap(b[i],b[i - 1]);i --;&#125;
    &#125;
    else
    &#123;
        puts(&quot;Heap Sort&quot;);
        int size = n;
        while(size &gt; 1 &amp;&amp; b[1] &lt;= b[size]) size --; 
        swap(b[1],b[size --]);
        down(1,size);
    &#125;
    cout &lt;&lt; b[1];
    for(int i = 2;i &lt;= n;i ++) cout &lt;&lt; &#39; &#39; &lt;&lt; b[i];
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E6%8E%92%E5%BA%8F/" style="color: #03a9f4">排序</a>
        </span>
        
    </div>
    <a href="/2022/11/05/%E6%8F%92%E5%85%A5%E8%BF%98%E6%98%AF%E5%A0%86%E6%8E%92%E5%BA%8F/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/27/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/">
        <h2 class="post-title">对称的二叉树</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/9/27
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/38/">https://www.acwing.com/problem/content/38/</a><br> <p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p></p>
<p>如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<h4>数据范围</h4>
<p>树中节点数量 $[0,100]$。</p>
<h4>样例</h4>
<pre><code>如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：
    1
   / \
  2   2
 / \ / \
3  4 4  3

<p>如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：<br>    1<br>   &#x2F; <br>  2   2<br>   \ &#x2F; <br>   4 4  3<br></code></pre></p>
<p>$O(n)递归写法$<br>一棵树是对称二叉树，<strong>当且仅当</strong>，两颗子树的根节点相等，第一棵子树的左子树和第二棵子树的右子树互相对称，且第一棵子树的右子树和第二棵子树的左子树互相对称。<br><strong>递归是一个很巧妙的思路，感觉对于很多问题的处理，只要是存在子集的结构，都可以使用递归的思想（注：空集的子集是它本身，所以只要是一个集合，都会有子集的概念，这也就使得递归和分治成为一种很普遍的思想）</strong><br>本题看了y总写的，比较妙的一点是对于状态的判断的处理，省下了很多if()语句，但是直接理解起来有点难，遂加上注释以助于理解(核心在于返回的对象可以是一个表达式)</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    bool isSymmetric(TreeNode* root) &#123;
        return !root || dfs(root-&gt;left,root-&gt;right);//如果根是空节点返回true，如果不空，递归到左右子树，如果对称也返回true。
    &#125;
    bool dfs(TreeNode* p,TreeNode* q)&#123;
        if(!p || !q) return !p &amp;&amp; !q;//如果两个节点有一个为空，那么两个节点都为空才返回true
        //否则
        return p-&gt;val == q-&gt;val &amp;&amp; dfs(p-&gt;left,q-&gt;right) &amp;&amp; dfs(p-&gt;right,q-&gt;left);//只有两个根节点值相等，且子树对称，才返回true。
    &#125;
    
&#125;;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/LeetCode/" style="color: #00bcd4">LeetCode</a>
        </span>
        
    </div>
    <a href="/2022/09/27/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/09/26/%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF/">
        <h2 class="post-title">通信线路</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/9/26
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>题目链接：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/342/">https://www.acwing.com/problem/content/342/</a></p>
<p>在郊区有 $N$ 座通信基站，$P$ 条 <strong>双向</strong> 电缆，第 $i$ 条电缆连接基站 $A_i$ 和 $B_i$。</p>
<p>特别地，$1$ 号基站是通信公司的总站，$N$ 号基站位于一座农场中。</p>
<p>现在，农场主希望对通信线路进行升级，其中升级第 $i$ 条电缆需要花费 $L_i$。</p>
<p>电话公司正在举行优惠活动。</p>
<p>农产主可以指定一条从 $1$ 号基站到 $N$ 号基站的路径，并指定路径上不超过 $K$ 条电缆，由电话公司免费提供升级服务。</p>
<p>农场主只需要支付在该路径上剩余的电缆中，升级价格最贵的那条电缆的花费即可。</p>
<p>求至少用多少钱可以完成升级。</p>
<h4>输入格式</h4>
<p>第 $1$ 行：三个整数 $N，P，K$。</p>
<p>第 $2..P+1$ 行：第 $i+1$ 行包含三个整数 $A_i,B_i,L_i$。</p>
<h4>输出格式</h4>
<p>包含一个整数表示最少花费。</p>
<p>若 $1$ 号基站与 $N$ 号基站之间不存在路径，则输出 $-1$。</p>
<h4>数据范围</h4>
<p>$0 \le K &lt; N \le 1000$,<br />
$1 \le P \le 10000$,<br />
$1 \le L_i \le 1000000$</p>
<h4>输入样例：</h4>
<pre><code>5 7 1
1 2 5
3 1 4
2 4 8
3 2 3
5 2 9
3 4 7
4 5 6
</code></pre>

<h4>输出样例：</h4>
<pre><code>4
</code></pre>

<p><strong>1：</strong>这里一条路径的权值定义为路径当中的第k + 1大值。<br>    我们要求第k + 1大值最小，求一个什么什么最小，<strong>可以很自然想到二分</strong>。<br>    想用二分要证明，看是否能找到一个性质满足以答案为基点划分，使得区间左右一个命题为真，一个命题为假。<br>    这里我们分析限制条件，来用作命题：<strong>是否存在一个x，<em>使得存在这样一条路径_：_从1走到n，经过大于等于x的边的数量小于等于k</em></strong></p>
<p><strong>2：</strong>接下来我们的问题变成了：**<em>给定一个权值x，如何测得是否存在一条路径，使得路径中边权值大于等于x的边的数量小于等于K。</em>**<br>    直接在图里面跑一遍最短路，重新**<em>记边权大于等于x的边的边权为1，否则为0</em><strong>.求一个</strong>最少<strong>大于等于边权x的边的数量。<br>    求出来之后，就算是</strong>求出来了一条1~n的路径**。满足该路径下，边权大于等于x的边的数量小于等于k。</p>
<p><strong>3：</strong>一点疑惑：同样都是<strong>“要求出来一条路径”</strong>，为什么我们挑选<strong>“这样的边最少的路径”</strong>也符合答案呢？（毕竟跑的是最短路径）如果稍微扰动一下，考虑另外一条路径B，这里的大于x的边的数量稍微多一些，会怎么样？<br>我们刚才求出来的是“最少的边数”小于等于k，稍微大一点了，可能仍然小于等于k啊。<br><strong>3.1</strong>解答：确实是这样。但是回头看看<strong>我们要证明的是一个存在性性质</strong>。<strong>只要说明有一条就好了</strong>，这样的话我们就找最短路径就OK。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
using namespace std;
const int N = 1010,M = 20010;
int n,p,k;
int h[N],e[M],ne[M],w[M],idx;
deque&lt;int&gt; q;
int dist[N];
bool st[N];
void add(int a,int b,int c)
&#123;
    e[idx] = b,ne[idx] = h[a],w[idx] = c,h[a] = idx ++;
&#125;
bool check(int x)
&#123;
    memset(dist,0x3f,sizeof dist);
    memset(st,0,sizeof st);
    q.push_back(1);
    dist[1] = 0;
    while(q.size())
    &#123;
        auto t = q.front();
        q.pop_front();
        if(st[t]) continue;
        st[t] = true;
        for(int i = h[t];~i;i = ne[i])
        &#123;
            int j = e[i],weight = w[i] &gt; x;
            if(dist[j] &gt; dist[t] + weight)
            &#123;
                dist[j] = dist[t] + weight;
                if(!weight) q.push_front(j);
                else q.push_back(j);
            &#125;
            
        &#125;
    &#125;
    return dist[n] &lt;= k;
&#125;
int main()
&#123;
    cin &gt;&gt; n &gt;&gt; p &gt;&gt; k;
    memset(h,-1,sizeof h);
    for(int i = 0;i &lt; p;i ++)
    &#123;
        int a,b,c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        add(a,b,c),add(b,a,c);
    &#125;
    int l = 0,r = 1e6 + 1;//设置r为1e6+1是为了辨析两种情况：出现不存在“最小值”的情况返回1e6+1，如果最小值就是1e6那就返回1e6
    while(l &lt; r)
    &#123;
        int mid = l + r &gt;&gt; 1;
        if(check(mid))  r = mid;
        else l = mid + 1;
    &#125;
    if(l == 1e6 + 1) printf(&quot;-1&quot;);
    else printf(&quot;%d&quot;,l);
    return 0;
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="color: #ff7d73">图论</a>
        </span>
        
    </div>
    <a href="/2022/09/26/%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2022/08/01/pointer/">
        <h2 class="post-title">What is a pointer?</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/8/1
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>先贴一个解释指针很好的博客<a href="https://">https://www.cnblogs.com/zhangrxiang/articles/8465678.html</a> </p>
<hr>
<p>再分享一篇看到的文章：<br><strong>本文从编译器的角度解释了变量即对象，解析了变量的rvalue和lvalue，从lvalue的角度引出了对指针的看法</strong></p>
<hr>
<p><strong><em>One of those things beginners in C find difficult is the concept of pointers. The purpose of this tutorial is to provide an introduction to pointers and their use to these beginners.One of those things beginners in C find difficult is the concept of pointers. The purpose of this tutorial is to provide an introduction to pointers and their use to these beginners.</em></strong></p>
<p><strong><em>I have found that often the main reason beginners have a problem with pointers is that they have a weak or minimal feeling for variables, (as they are used in C). Thus we start with a discussion of C variables in general.</em></strong></p>
<p><strong><em>A variable in a program is something with a name, the value of which can vary. The way the compiler and linker handles this is that it assigns a specific block of memory within the computer to hold the value of that variable. The size of that block depends on the range over which the variable is allowed to vary. For example, on 32 bit PC’s the size of an integer variable is 4 bytes. On older 16 bit PCs integers were 2 bytes.  In C the size of a variable type such as an integer need not be the same on all types of machines.  Further more there is more than one type of integer variable in C.  We have integers, long integers and short integers which you can read up on in any basic text on C.  This document assumes the use of a 32 bit system with 4 byte integers.</em></strong></p>
<p><strong><em>If you want to know the size of the various types of integers on your system, running the following code will give you that information.</em></strong></p>
<pre><code>#include &lt;stdio.h&gt;

int main()
&#123;
printf(&quot;size of a short is %d\n&quot;, sizeof(short));
printf(&quot;size of a int is %d\n&quot;, sizeof(int));
printf(&quot;size of a long is %d\n&quot;, sizeof(long));
&#125;
</code></pre>
<hr>
<p><strong><em>When we declare a variable we inform the compiler of two things, the name of the variable and the type of the variable. For example, we declare a variable of type integer with the name k by writing:</em></strong></p>
<pre><code>int k; 
</code></pre>
<p>**<em>On seeing the “int” part of this statement the compiler sets aside 4 bytes of memory (on a PC) to hold the value of the integer. It also sets up a symbol table. In that table it adds the symbol k and the relative address in memory where those 4 bytes were set aside.</em>**（变量的构成）</p>
<p><strong><em>Thus, later if we write:</em></strong></p>
<pre><code>k = 2; 
</code></pre>
<p>**<em>we expect that, at run time when this statement is executed, the value 2 will be placed in that memory location reserved for the storage of the value of k. In C we refer to a variable such as the integer k as an “object”.</em> **（在C中，变量，即可以看作一个对象）</p>
<hr>
<p>对于一个对象的加深理解：一个对象具有两个值(“are value” 和 “lvalue”)<br><strong><em>In a sense there are two “values” associated with the object k. One is the value of the integer stored there (2 in the above example) and the other the “value” of the memory location, i.e., the address of k. Some texts refer to these two values with the nomenclature rvalue (right value, pronounced “are value”) and lvalue (left value, pronounced “el value”) respectively.</em></strong></p>
<p><strong><em>In some languages, the lvalue is the value permitted on the left side of the assignment operator ‘&#x3D;’ (i.e. the address where the result of evaluation of the right side ends up). The rvalue is that which is on the right side of the assignment statement, the 2 above. Rvalues cannot be used on the left side of the assignment statement. Thus: 2 &#x3D; k; is illegal.</em></strong></p>
<p><strong><em>Actually, the above definition of “lvalue” is somewhat modified for C. According to K&amp;R II (page 197): [1]</em></strong></p>
<p><strong><em>“An object is a named region of storage; an lvalue is an expression referring to an object.”</em></strong><br>(对象是命名的存储区域；左值是对“对象引用”的表达)<br><strong><em>However, at this point, the definition originally cited above is sufficient. As we become more familiar with pointers we will go into more detail on this.</em></strong></p>
<p><strong><em>Okay, now consider:</em></strong></p>
<pre><code>   int j, k; 

    k = 2; 
    j = 7;    &lt;-- line 1 
    k = j;    &lt;-- line 2 
</code></pre>
<p>（从编译器的角度解释变量(object)，提出address的必要性）<br><strong><em>In the above, the compiler interprets the j in line 1 as the address of the variable j (its lvalue) and creates code to copy the value 7 to that address. In line 2, however, the j is interpreted as its rvalue (since it is on the right hand side of the assignment operator ‘&#x3D;’). That is, here the j refers to the value stored at the memory location set aside for j, in this case 7. So, the 7 is copied to the address designated by the lvalue of k.</em></strong></p>
<p><strong><em>In all of these examples, we are using 4 byte integers so all copying of rvalues from one storage location to the other is done by copying 4 bytes. Had we been using two byte integers, we would be copying 2 bytes.</em></strong></p>
<hr>
<p>（引出了指针的概念）：得到对象的左值</p>
<p><strong><em>Now, let’s say that we have a reason for wanting a variable designed to hold an lvalue (an address). The size required to hold such a value depends on the system. On older desk top computers with 64K of memory total, the address of any point in memory can be contained in 2 bytes. Computers with more memory would require more bytes to hold an address.  The actual size required is not too important so long as we have a way of informing the compiler that what we want to store is an address.</em></strong></p>
<p><strong><em>Such a variable is called a pointer variable (for reasons which hopefully will become clearer a little later). In C when we define a pointer variable we do so by preceding its name with an asterisk. In C we also give our pointer a type which, in this case, refers to the type of data stored at the address we will be storing in our pointer. For example, consider the variable declaration:</em></strong></p>
<pre><code>int *ptr;
</code></pre>
<p>(核心句：However many bytes is required to store an address in memory)<br><strong><em>ptr is the name of our variable (just as k was the name of our integer variable). The ‘*’ informs the compiler that we want a pointer variable, i.e. to set aside however many bytes is required to store an address in memory. 《The int says that we intend to “use our pointer variable（工具人）” to store the address of an integer. Such a pointer is said to “point to” an integer.（打工人） 》However, note that when we wrote int k; we did not give k a value. If this definition is made outside of any function ANSI compliant compilers will initialize it to zero. Similarly, ptr has no value, that is we haven’t stored an address in it in the above declaration. In this case, again if the declaration is outside of any function, it is initialized to a value guaranteed in such a way that it is guaranteed to not point to any C object or function. A pointer initialized in this manner is called a “null” pointer.</em></strong></p>
<hr>
<p>（对于空指针的定义不同系统是不一样的，不一定都是“0”，但是无论如何我们把<strong>空指针用宏写成NULL</strong>，就可以方便代码做移植，这里做了一层抽象）</p>
<p><strong><em>The actual bit pattern used for a null pointer may or may not evaluate to zero since it depends on the specific system on which the code is developed. To make the source code compatible between various compilers on various systems, a macro is used to represent a null pointer. That macro goes under the name NULL. Thus, setting the value of a pointer using the NULL macro, as with an assignment statement such as ptr &#x3D; NULL, guarantees that the pointer has become a null pointer. Similarly, just as one can test for an integer value of zero, as in if(k &#x3D;&#x3D; 0), we can test for a null pointer using if (ptr &#x3D;&#x3D; NULL).</em></strong></p>
<p><strong><em>But, back to using our new variable ptr. Suppose now that we want to store in ptr the address of our integer variable k. To do this we use the unary（单元运算符） &amp; operator and write:</em></strong></p>
<pre><code>ptr = &amp;k; 
</code></pre>
<p><strong><em>What the &amp; operator does is retrieve the lvalue (address) of k, even though k is on the right hand side of the assignment operator ‘&#x3D;’, and copies that to the contents of our pointer ptr. Now, ptr is said to “point to” k. Bear with us now, there is only one more operator we need to discuss.</em></strong></p>
<p><strong><em>The “dereferencing operator”(解引用) is the asterisk and it is used as follows:</em></strong></p>
<pre><code>*ptr = 7; 
</code></pre>
<p><strong><em>will copy 7 to the address pointed to by ptr. Thus if ptr “points to” (contains the address of) k, the above statement will set the value of k to 7. That is, when we use the ‘*’ this way we are referring to the value of that which ptr is pointing to, not the value of the pointer itself.</em></strong></p>
<p><strong><em>Similarly, we could write:</em></strong></p>
<pre><code> printf(&quot;%d\n&quot;,*ptr); 
</code></pre>
<p><strong><em>to print to the screen the integer value stored at the address pointed to by ptr;.</em></strong></p>
<p><strong><em>One way to see how all this stuff fits together would be to run the following program and then review the code and the output carefully.</em></strong></p>
<p>———— Program 1.1 ———————————</p>
<pre><code> 1 /* Program 1.1 from PTRTUT10.TXT   6/10/97 */
 2 
 3 #include &lt;stdio.h&gt;
 4 
 5 int j, k;
 6 int *ptr;
 7 
 8 int main(void)
 9 &#123;
10     j = 1;
11     k = 2;
12     ptr = &amp;k;
13     printf(&quot;\n&quot;);
14     printf(&quot;j has the value %d and is stored at %p\n&quot;, j, (void *)&amp;j);
15     printf(&quot;k has the value %d and is stored at %p\n&quot;, k, (void *)&amp;k);
16     printf(&quot;ptr has the value %p and is stored at %p\n&quot;, ptr, (void *)&amp;ptr);
17     printf(&quot;The value of the integer pointed to by ptr is %d\n&quot;, *ptr);
18 
19     return 0;
20 &#125;
</code></pre>
<p>**<em>Note: We have yet to discuss those aspects of C which require the use of the (void *) expression used here. For now, include it in your test code. We’ll explain the reason behind this expression later.</em>**</p>
<p><strong><em>To review:</em></strong></p>
<p><strong><em>A variable is declared by giving it a type and a name (e.g. int k;)</em></strong><br>**<em>A pointer variable is declared by giving it a type and a name (e.g. int *ptr) where the asterisk tells the compiler that the variable named ptr is a pointer variable and the type tells the compiler what type the pointer is to point to (integer in this case).</em>**<br><strong><em>Once a variable is declared, we can get its address by preceding its name with the unary &amp; operator, as in &amp;k.</em></strong><br>**<em>We can “dereference” a pointer, i.e. refer to the value of that which it points to, by using the unary ‘*’ operator as in *ptr.</em>**<br><strong><em>An “lvalue” of a variable is the value of its address, i.e. where it is stored in memory. The “rvalue” of a variable is the value stored in that variable (at that address).</em></strong><br><strong><em>References for Chapter 1:</em></strong><br><strong><em>“The C Programming Language” 2nd Edition</em></strong><br><strong>_B. Kernighan and D. Ritchie _</strong><br><strong>_Prentice Hall _</strong><br><strong><em>ISBN 0-13-110362-8 A variable is declared by giving it a type and a name (e.g. int k;)</em></strong><br><strong><em>A variable is declared by giving it a type and a name (e.g. int k;)</em></strong><br>**<em>A pointer variable is declared by giving it a type and a name (e.g. int *ptr) where the asterisk tells the compiler that the variable named ptr is a pointer variable and the type tells the compiler what type the pointer is to point to (integer in this case).</em>**</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86/" style="color: #ffa2c4">语言知识</a>
        </span>
        
    </div>
    <a href="/2022/08/01/pointer/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    <div class="prev">
        
        <a class="page-num" href="/">
            <i class="fa-solid fa-caret-left fa-fw"></i>
        </a>
        
    </div>
    <div class="page-index">
        
        <span>
            
            
            <a class="page-num" href="/">1</a>
        </span>
        
        <span class="current">2</span>
        
        <span>
            <a class="page-num" href="/page/3/">3</a>
            
            <a class="page-num" href="/page/4">4</a>
            
            
        </span>
        
    </div>
    <div class="next">
        
        <a class="page-num" href="/page/3/">
            <i class="fa-solid fa-caret-right fa-fw"></i>
        </a>
        
    </div>
</div>

    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style">
        <div class="avatar">
            <img src="/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">金冠小熊猫</div>
        <div class="description">
            <p>Description<br>…</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.github.io">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 金冠小熊猫
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;金冠小熊猫
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

                </div>
            </transition>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
    </body>
</html>
